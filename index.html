<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pathfinding Visualizer</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a1a; }
    /* Hide scrollbar but allow scrolling */
    nav::-webkit-scrollbar, .grid-container::-webkit-scrollbar { display: none; }
    nav, .grid-container { -ms-overflow-style: none; scrollbar-width: none; }
    @media (max-width: 768px) {
      nav { flex-wrap: nowrap !important; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useRef, useCallback, useEffect } = React;

const GridUtils = {
  CONFIGS: {
    hex: {
      directions: [
        { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
        { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 },
      ],
      formations: {
        1: [{ q: 0, r: 0 }],
        3: [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: 0, r: 1 }],
        7: [
          { q: 0, r: 0 }, { q: 1, r: 0 }, { q: 1, r: -1 },
          { q: 0, r: -1 }, { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
        ],
      },
      unitSizes: [1, 3, 7],
      unitLabels: { 1: '1â¬¡', 3: '3â–³', 7: '7â¬¢' },
      heuristics: ['hex', 'euclidean'],
      defaultHeuristic: 'hex',
    },
    square4: {
      directions: [
        { q: 0, r: -1 }, { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 0 },
      ],
      formations: {
        1: [{ q: 0, r: 0 }],
        4: [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: 0, r: 1 }, { q: 1, r: 1 }],
        9: [
          { q: -1, r: -1 }, { q: 0, r: -1 }, { q: 1, r: -1 },
          { q: -1, r: 0 }, { q: 0, r: 0 }, { q: 1, r: 0 },
          { q: -1, r: 1 }, { q: 0, r: 1 }, { q: 1, r: 1 }
        ],
      },
      unitSizes: [1, 4, 9],
      unitLabels: { 1: '1â–¡', 4: '2Ã—2', 9: '3Ã—3' },
      heuristics: ['manhattan', 'euclidean'],
      defaultHeuristic: 'manhattan',
    },
    square8: {
      directions: [
        { q: 0, r: -1 }, { q: 1, r: -1 }, { q: 1, r: 0 }, { q: 1, r: 1 },
        { q: 0, r: 1 }, { q: -1, r: 1 }, { q: -1, r: 0 }, { q: -1, r: -1 },
      ],
      formations: {
        1: [{ q: 0, r: 0 }],
        4: [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: 0, r: 1 }, { q: 1, r: 1 }],
        9: [
          { q: -1, r: -1 }, { q: 0, r: -1 }, { q: 1, r: -1 },
          { q: -1, r: 0 }, { q: 0, r: 0 }, { q: 1, r: 0 },
          { q: -1, r: 1 }, { q: 0, r: 1 }, { q: 1, r: 1 }
        ],
      },
      unitSizes: [1, 4, 9],
      unitLabels: { 1: '1â–¡', 4: '2Ã—2', 9: '3Ã—3' },
      heuristics: ['chebyshev', 'euclidean', 'manhattan'],
      defaultHeuristic: 'chebyshev',
    },
  },

  getConfig: (gridType) => GridUtils.CONFIGS[gridType] || GridUtils.CONFIGS.hex,
  getDirections: (gridType) => GridUtils.getConfig(gridType).directions,
  getFormationOffsets: (gridType, size) => {
    const config = GridUtils.getConfig(gridType);
    return config.formations[size] || config.formations[1];
  },
  getFormationCells: (gridType, centerQ, centerR, size) => {
    const offsets = GridUtils.getFormationOffsets(gridType, size);
    return offsets.map(offset => ({ q: centerQ + offset.q, r: centerR + offset.r }));
  },
  canFormationFit: (grid, gridType, centerQ, centerR, size, ignoreKeys = new Set()) => {
    const cells = GridUtils.getFormationCells(gridType, centerQ, centerR, size);
    for (const cell of cells) {
      const key = GridUtils.cellKey(cell.q, cell.r);
      if (ignoreKeys.has(key)) continue;
      const node = grid.get(key);
      if (!node || node.isWall) return false;
    }
    return true;
  },
  getFormationClearance: (grid, gridType, centerQ, centerR, size) => {
    if (size === 1) return 0;
    const cells = GridUtils.getFormationCells(gridType, centerQ, centerR, size);
    let blockedNeighbors = 0;
    for (const cell of cells) {
      const neighbors = GridUtils.getNeighbors(gridType, cell.q, cell.r);
      for (const n of neighbors) {
        const key = GridUtils.cellKey(n.q, n.r);
        const node = grid.get(key);
        if (!node || node.isWall) blockedNeighbors++;
      }
    }
    return blockedNeighbors * 0.1;
  },
  cellKey: (q, r) => `${q},${r}`,
  parseKey: (key) => { const [q, r] = key.split(',').map(Number); return { q, r }; },
  getNeighbors: (gridType, q, r) => {
    const dirs = GridUtils.getDirections(gridType);
    return dirs.map(d => ({ q: q + d.q, r: r + d.r }));
  },
  axialToCube: (q, r) => ({ x: q, y: -q - r, z: r }),
  cubeDistance: (a, b) => Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z)),
  hexDistance: (q1, r1, q2, r2) => {
    const a = GridUtils.axialToCube(q1, r1);
    const b = GridUtils.axialToCube(q2, r2);
    return GridUtils.cubeDistance(a, b);
  },
  hexToPixel: (q, r, size) => ({
    x: size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r),
    y: size * (3 / 2 * r)
  }),
  axialRound: (q, r) => {
    const cube = GridUtils.axialToCube(q, r);
    let rx = Math.round(cube.x), ry = Math.round(cube.y), rz = Math.round(cube.z);
    const xDiff = Math.abs(rx - cube.x), yDiff = Math.abs(ry - cube.y), zDiff = Math.abs(rz - cube.z);
    if (xDiff > yDiff && xDiff > zDiff) rx = -ry - rz;
    else if (yDiff > zDiff) ry = -rx - rz;
    else rz = -rx - ry;
    return { q: rx, r: rz };
  },
  hexCorners: (cx, cy, size) => {
    const corners = [];
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 180 * (60 * i - 30);
      corners.push({ x: cx + size * Math.cos(angle), y: cy + size * Math.sin(angle) });
    }
    return corners;
  },
  squareToPixel: (q, r, size) => ({ x: q * size * 2, y: r * size * 2 }),
  cellToPixel: (gridType, q, r, size) => gridType === 'hex' ? GridUtils.hexToPixel(q, r, size) : GridUtils.squareToPixel(q, r, size),
  manhattanDistance: (q1, r1, q2, r2) => Math.abs(q1 - q2) + Math.abs(r1 - r2),
  chebyshevDistance: (q1, r1, q2, r2) => Math.max(Math.abs(q1 - q2), Math.abs(r1 - r2)),
  euclideanDistance: (q1, r1, q2, r2) => Math.sqrt((q1 - q2) ** 2 + (r1 - r2) ** 2),
  getDistance: (gridType, heuristic, q1, r1, q2, r2) => {
    switch (heuristic) {
      case 'hex': return GridUtils.hexDistance(q1, r1, q2, r2);
      case 'manhattan': return GridUtils.manhattanDistance(q1, r1, q2, r2);
      case 'chebyshev': return GridUtils.chebyshevDistance(q1, r1, q2, r2);
      case 'euclidean': return GridUtils.euclideanDistance(q1, r1, q2, r2);
      default:
        if (gridType === 'hex') return GridUtils.hexDistance(q1, r1, q2, r2);
        if (gridType === 'square4') return GridUtils.manhattanDistance(q1, r1, q2, r2);
        return GridUtils.chebyshevDistance(q1, r1, q2, r2);
    }
  },
  getMovementCost: (gridType, dq, dr, baseWeight) => {
    if (gridType === 'hex') return baseWeight;
    if (gridType === 'square8' && dq !== 0 && dr !== 0) return baseWeight * 1.414;
    return baseWeight;
  },
};

class MinHeap {
  constructor() { this.heap = []; }
  push(item, priority) { this.heap.push({ item, priority }); this.bubbleUp(this.heap.length - 1); }
  pop() {
    if (this.heap.length === 0) return null;
    const min = this.heap[0];
    const end = this.heap.pop();
    if (this.heap.length > 0) { this.heap[0] = end; this.bubbleDown(0); }
    return min.item;
  }
  isEmpty() { return this.heap.length === 0; }
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (this.heap[parentIndex].priority <= this.heap[index].priority) break;
      [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
      index = parentIndex;
    }
  }
  bubbleDown(index) {
    const length = this.heap.length;
    while (true) {
      const leftChild = 2 * index + 1, rightChild = 2 * index + 2;
      let smallest = index;
      if (leftChild < length && this.heap[leftChild].priority < this.heap[smallest].priority) smallest = leftChild;
      if (rightChild < length && this.heap[rightChild].priority < this.heap[smallest].priority) smallest = rightChild;
      if (smallest === index) break;
      [this.heap[smallest], this.heap[index]] = [this.heap[index], this.heap[smallest]];
      index = smallest;
    }
  }
}

const Algorithms = {
  aStar: (grid, start, end, heuristicWeight = 1, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScore = new Map(), fScore = new Map(), previous = new Map(), visited = [], formationState = new Map();
    gScore.set(startKey, 0);
    fScore.set(startKey, heuristicWeight * GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    formationState.set(startKey, true);
    openSet.push(startKey, fScore.get(startKey));
    const inOpenSet = new Set([startKey]);
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      if (currentKey === endKey) return { previous, visited, endKey, gScore, fScore, formationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentNode = grid.get(currentKey);
      if (!currentNode) continue;
      const currentIsCompact = formationState.get(currentKey) ?? true;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        const dq = neighbor.q - current.q, dr = neighbor.r - current.r;
        let moveCost = GridUtils.getMovementCost(gridType, dq, dr, 1);
        let neighborIsCompact = canFitCompact;
        if (unitSize > 1) {
          if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
          else if (canSnake) { neighborIsCompact = false; moveCost += currentIsCompact ? snakePenalty : snakePenalty * 0.15; }
        }
        const tentativeG = gScore.get(currentKey) + moveCost;
        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
          previous.set(neighborKey, currentKey);
          gScore.set(neighborKey, tentativeG);
          formationState.set(neighborKey, neighborIsCompact);
          const f = tentativeG + heuristicWeight * GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r);
          fScore.set(neighborKey, f);
          if (!inOpenSet.has(neighborKey)) { openSet.push(neighborKey, f); inOpenSet.add(neighborKey); }
        }
      }
    }
    return { previous, visited, endKey: null, gScore, fScore, formationState };
  },
  dijkstra: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false, snakePenalty = 1.5) => Algorithms.aStar(grid, start, end, 0, gridType, 'default', unitSize, canSnake, snakePenalty),
  greedyBestFirst: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const previous = new Map(), visited = [], gScore = new Map(), formationState = new Map();
    openSet.push(startKey, GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    const inOpenSet = new Set([startKey]);
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        if (previous.has(neighborKey) || neighborKey === startKey) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        previous.set(neighborKey, currentKey);
        formationState.set(neighborKey, canFitCompact);
        let moveCost = 1;
        if (unitSize > 1) { if (canFitCompact) moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); else if (canSnake) moveCost += currentIsCompact ? snakePenalty : snakePenalty * 0.15; }
        gScore.set(neighborKey, (gScore.get(currentKey) || 0) + moveCost);
        openSet.push(neighborKey, GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r));
        inOpenSet.add(neighborKey);
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  bfs: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false) => {
    const queue = [];
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const previous = new Map(), visited = [], gScore = new Map(), formationState = new Map();
    queue.push(startKey);
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    const inQueue = new Set([startKey]);
    while (queue.length > 0) {
      const currentKey = queue.shift();
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      visited.push(currentKey);
      for (const neighbor of GridUtils.getNeighbors(gridType, GridUtils.parseKey(currentKey).q, GridUtils.parseKey(currentKey).r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        if (inQueue.has(neighborKey)) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        previous.set(neighborKey, currentKey);
        formationState.set(neighborKey, canFitCompact);
        gScore.set(neighborKey, (gScore.get(currentKey) || 0) + 1);
        queue.push(neighborKey);
        inQueue.add(neighborKey);
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  dfs: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false) => {
    const stack = [];
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const previous = new Map(), visited = [], gScore = new Map(), formationState = new Map();
    stack.push(startKey);
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    const inStack = new Set([startKey]);
    while (stack.length > 0) {
      const currentKey = stack.pop();
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      visited.push(currentKey);
      for (const neighbor of GridUtils.getNeighbors(gridType, GridUtils.parseKey(currentKey).q, GridUtils.parseKey(currentKey).r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        if (inStack.has(neighborKey)) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        previous.set(neighborKey, currentKey);
        formationState.set(neighborKey, canFitCompact);
        gScore.set(neighborKey, (gScore.get(currentKey) || 0) + 1);
        stack.push(neighborKey);
        inStack.add(neighborKey);
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  swarm: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScore = new Map(), previous = new Map(), visited = [], formationState = new Map();
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    openSet.push(startKey, GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    const inOpenSet = new Set([startKey]);
    let iteration = 0;
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      iteration++;
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        let moveCost = 1, neighborIsCompact = canFitCompact;
        if (unitSize > 1) {
          if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
          else if (canSnake) { neighborIsCompact = false; moveCost += currentIsCompact ? snakePenalty : snakePenalty * 0.15; }
        }
        const tentativeG = gScore.get(currentKey) + moveCost;
        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
          previous.set(neighborKey, currentKey);
          gScore.set(neighborKey, tentativeG);
          formationState.set(neighborKey, neighborIsCompact);
          const h = GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r);
          if (!inOpenSet.has(neighborKey)) { openSet.push(neighborKey, tentativeG + (1 + (h / (iteration + 1)) * 2) * h); inOpenSet.add(neighborKey); }
        }
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  convergentSwarm: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScore = new Map(), previous = new Map(), visited = [], formationState = new Map();
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    const maxH = GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r);
    openSet.push(startKey, maxH);
    const inOpenSet = new Set([startKey]);
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        let moveCost = 1, neighborIsCompact = canFitCompact;
        if (unitSize > 1) {
          if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
          else if (canSnake) { neighborIsCompact = false; moveCost += currentIsCompact ? snakePenalty : snakePenalty * 0.15; }
        }
        const tentativeG = gScore.get(currentKey) + moveCost;
        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
          previous.set(neighborKey, currentKey);
          gScore.set(neighborKey, tentativeG);
          formationState.set(neighborKey, neighborIsCompact);
          const h = GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r);
          const progress = 1 - (h / maxH);
          if (!inOpenSet.has(neighborKey)) { openSet.push(neighborKey, tentativeG + (1 + (1 - progress) * 3) * h); inOpenSet.add(neighborKey); }
        }
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  bidirectionalSwarm: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSetStart = new MinHeap(), openSetEnd = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScoreStart = new Map(), gScoreEnd = new Map();
    const previousStart = new Map(), previousEnd = new Map();
    const visitedStart = new Set(), visitedEnd = new Set();
    const visited = [], formationStateStart = new Map(), formationStateEnd = new Map();
    gScoreStart.set(startKey, 0); gScoreEnd.set(endKey, 0);
    formationStateStart.set(startKey, true); formationStateEnd.set(endKey, true);
    openSetStart.push(startKey, GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    openSetEnd.push(endKey, GridUtils.getDistance(gridType, heuristic, end.q, end.r, start.q, start.r));
    const inOpenStart = new Set([startKey]), inOpenEnd = new Set([endKey]);
    let meetingPoint = null;
    while (!openSetStart.isEmpty() && !openSetEnd.isEmpty()) {
      if (!openSetStart.isEmpty()) {
        const currentKey = openSetStart.pop(); inOpenStart.delete(currentKey); visitedStart.add(currentKey); visited.push(currentKey);
        if (visitedEnd.has(currentKey)) { meetingPoint = currentKey; break; }
        const current = GridUtils.parseKey(currentKey);
        const currentIsCompact = formationStateStart.get(currentKey) ?? true;
        for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
          const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
          const neighborNode = grid.get(neighborKey);
          if (!neighborNode || neighborNode.isWall || visitedStart.has(neighborKey)) continue;
          const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
          if (!canFitCompact && !canSnake) continue;
          let moveCost = 1, neighborIsCompact = canFitCompact;
          if (unitSize > 1) {
            if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
            else if (canSnake) { neighborIsCompact = false; moveCost += currentIsCompact ? snakePenalty : snakePenalty * 0.15; }
          }
          const tentativeG = gScoreStart.get(currentKey) + moveCost;
          if (!gScoreStart.has(neighborKey) || tentativeG < gScoreStart.get(neighborKey)) {
            previousStart.set(neighborKey, currentKey); gScoreStart.set(neighborKey, tentativeG); formationStateStart.set(neighborKey, neighborIsCompact);
            if (!inOpenStart.has(neighborKey)) { openSetStart.push(neighborKey, tentativeG + GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r)); inOpenStart.add(neighborKey); }
          }
        }
      }
      if (!openSetEnd.isEmpty()) {
        const currentKey = openSetEnd.pop(); inOpenEnd.delete(currentKey); visitedEnd.add(currentKey); visited.push(currentKey);
        if (visitedStart.has(currentKey)) { meetingPoint = currentKey; break; }
        const current = GridUtils.parseKey(currentKey);
        const currentIsCompact = formationStateEnd.get(currentKey) ?? true;
        for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
          const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
          const neighborNode = grid.get(neighborKey);
          if (!neighborNode || neighborNode.isWall || visitedEnd.has(neighborKey)) continue;
          const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
          if (!canFitCompact && !canSnake) continue;
          let moveCost = 1, neighborIsCompact = canFitCompact;
          if (unitSize > 1) {
            if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
            else if (canSnake) { neighborIsCompact = false; moveCost += currentIsCompact ? snakePenalty : snakePenalty * 0.15; }
          }
          const tentativeG = gScoreEnd.get(currentKey) + moveCost;
          if (!gScoreEnd.has(neighborKey) || tentativeG < gScoreEnd.get(neighborKey)) {
            previousEnd.set(neighborKey, currentKey); gScoreEnd.set(neighborKey, tentativeG); formationStateEnd.set(neighborKey, neighborIsCompact);
            if (!inOpenEnd.has(neighborKey)) { openSetEnd.push(neighborKey, tentativeG + GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, start.q, start.r)); inOpenEnd.add(neighborKey); }
          }
        }
      }
    }
    const mergedGScore = new Map(gScoreStart); for (const [k, v] of gScoreEnd) if (!mergedGScore.has(k)) mergedGScore.set(k, v);
    const mergedFormationState = new Map(formationStateStart); for (const [k, v] of formationStateEnd) if (!mergedFormationState.has(k)) mergedFormationState.set(k, v);
    return { previousStart, previousEnd, visitedStart: [...visitedStart], visitedEnd: [...visitedEnd], visited, meetingPoint, gScoreStart, gScoreEnd, gScore: mergedGScore, formationStateStart, formationStateEnd, formationState: mergedFormationState };
  },
  flowField: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const endKey = GridUtils.cellKey(end.q, end.r), startKey = GridUtils.cellKey(start.q, start.r);
    const costField = new Map(), flowVectors = new Map(), visited = [], formationState = new Map();
    const openSet = new MinHeap();
    costField.set(endKey, 0); formationState.set(endKey, true); openSet.push(endKey, 0);
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentCost = costField.get(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        const dq = neighbor.q - current.q, dr = neighbor.r - current.r;
        let moveCost = GridUtils.getMovementCost(gridType, dq, dr, 1);
        let neighborIsCompact = canFitCompact;
        if (unitSize > 1) {
          if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
          else if (canSnake) { neighborIsCompact = false; moveCost += currentIsCompact ? snakePenalty : snakePenalty * 0.15; }
        }
        const newCost = currentCost + moveCost;
        if (!costField.has(neighborKey) || newCost < costField.get(neighborKey)) { costField.set(neighborKey, newCost); formationState.set(neighborKey, neighborIsCompact); openSet.push(neighborKey, newCost); }
      }
    }
    for (const [key] of costField) {
      const current = GridUtils.parseKey(key);
      const currentCost = costField.get(key);
      let bestNeighbor = null, bestCost = currentCost;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborCost = costField.get(neighborKey);
        if (neighborCost !== undefined && neighborCost < bestCost) { bestCost = neighborCost; bestNeighbor = neighbor; }
      }
      if (bestNeighbor) flowVectors.set(key, { direction: { q: bestNeighbor.q - current.q, r: bestNeighbor.r - current.r } });
    }
    const path = [];
    let current = startKey;
    const pathVisited = new Set();
    while (current && current !== endKey && !pathVisited.has(current)) {
      pathVisited.add(current);
      const flow = flowVectors.get(current);
      if (!flow) break;
      const pos = GridUtils.parseKey(current);
      const nextKey = GridUtils.cellKey(pos.q + flow.direction.q, pos.r + flow.direction.r);
      path.push({ key: nextKey, isCompact: formationState.get(nextKey) ?? true });
      current = nextKey;
    }
    return { visited, path, costField, flowVectors, gScore: costField, formationState };
  },
};

function PathfindingVisualizer() {
  const [gridType, setGridType] = useState('hex');
  const [heuristic, setHeuristic] = useState('default');
  const [grid, setGrid] = useState(new Map());
  const [startNode, setStartNode] = useState({ q: -10, r: 0 });
  const [endNode, setEndNode] = useState({ q: 10, r: 0 });
  const [selectedAlgorithm, setSelectedAlgorithm] = useState('aStar');
  const [isRunning, setIsRunning] = useState(false);
  const [isDragging, setIsDragging] = useState(null);
  const [hoveredHex, setHoveredHex] = useState(null);
  const [speed, setSpeed] = useState('fast');
  const [stats, setStats] = useState({ visited: 0, pathLength: 0, time: 0 });
  const [unitSize, setUnitSize] = useState(1);
  const [canSnake, setCanSnake] = useState(false);
  const [snakePenalty, setSnakePenalty] = useState(1.5);
  const [heuristicWeight, setHeuristicWeight] = useState(1);
  const [showCellNumbers, setShowCellNumbers] = useState(false);
  const [showCostOverlay, setShowCostOverlay] = useState(false);
  const [costField, setCostField] = useState(new Map());
  const [flowVectors, setFlowVectors] = useState(new Map());
  const [showFlowVectors, setShowFlowVectors] = useState(true);
  const [hasVisualized, setHasVisualized] = useState(false);
  const [wallEditMode, setWallEditMode] = useState(null);
  const [algorithmDropdownOpen, setAlgorithmDropdownOpen] = useState(false);
  const algorithmDropdownRef = useRef(null);
  
  const algorithmInfo = {
    dijkstra: { name: "Dijkstra's", optimal: true, complete: true, desc: "Explores uniformly by cost â€” guaranteed shortest path", icon: 'ðŸŽ¯' },
    aStar: { name: 'A* Search', optimal: 'wâ‰¤1', complete: true, desc: 'Cost + heuristic guided â€” optimal when weight â‰¤ 1', icon: 'â­' },
    greedyBestFirst: { name: 'Greedy Best-First', optimal: false, complete: true, desc: 'Pure heuristic â€” very fast but often suboptimal', icon: 'ðŸƒ' },
    swarm: { name: 'Swarm', optimal: false, complete: true, desc: 'Dynamic weight decreases over iterations', icon: 'ðŸ' },
    convergentSwarm: { name: 'Convergent Swarm', optimal: false, complete: true, desc: 'Weight based on progress toward goal', icon: 'ðŸŒ€' },
    bidirectionalSwarm: { name: 'Bidirectional Swarm', optimal: false, complete: true, desc: 'Searches from both start and end simultaneously', icon: 'â†”ï¸' },
    flowField: { name: 'Flow Field', optimal: true, complete: true, desc: 'Vector field pointing to goal â€” great for many units', icon: 'ðŸŒŠ' },
    bfs: { name: 'Breadth-First (BFS)', optimal: 'unweighted', complete: true, desc: 'Level-by-level â€” optimal for uniform cost', icon: 'ðŸ“Š' },
    dfs: { name: 'Depth-First (DFS)', optimal: false, complete: false, desc: 'Goes deep first â€” fast but unpredictable paths', icon: 'ðŸ”' },
  };

  useEffect(() => {
    const handleClickOutside = (e) => {
      if (algorithmDropdownRef.current && !algorithmDropdownRef.current.contains(e.target)) {
        setAlgorithmDropdownOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const svgRef = useRef(null);
  const animationRef = useRef([]);
  const prevSettingsRef = useRef({ heuristicWeight, snakePenalty, canSnake, unitSize, selectedAlgorithm, gridType, heuristic });

  const CELL_SIZE = gridType === 'hex' ? 18 : 14;
  const SVG_WIDTH = 1200, SVG_HEIGHT = 800;
  const speedSettings = { fast: { visit: 5, path: 20 }, average: { visit: 20, path: 40 }, slow: { visit: 50, path: 80 } };
  const gridConfig = GridUtils.getConfig(gridType);

  const initializeGrid = useCallback(() => {
    const newGrid = new Map();
    if (gridType === 'hex') {
      const size = 18, sqrt3 = Math.sqrt(3), maxX = 580;
      for (let r = -14; r <= 14; r++) {
        const xOffsetFromR = size * (sqrt3 / 2) * r;
        const qSpacing = size * sqrt3;
        const minQ = Math.ceil((-maxX - xOffsetFromR) / qSpacing), maxQ = Math.floor((maxX - xOffsetFromR) / qSpacing);
        for (let q = minQ; q <= maxQ; q++) newGrid.set(GridUtils.cellKey(q, r), { q, r, isWall: false, isVisited: false, isPath: false, isStart: false, isEnd: false, animationState: 'none' });
      }
    } else {
      for (let q = -20; q <= 20; q++) for (let r = -13; r <= 13; r++) newGrid.set(GridUtils.cellKey(q, r), { q, r, isWall: false, isVisited: false, isPath: false, isStart: false, isEnd: false, animationState: 'none' });
    }
    const defaultStart = gridType === 'hex' ? { q: -14, r: 0 } : { q: -16, r: 0 };
    const defaultEnd = gridType === 'hex' ? { q: 14, r: 0 } : { q: 16, r: 0 };
    if (newGrid.has(GridUtils.cellKey(defaultStart.q, defaultStart.r))) newGrid.set(GridUtils.cellKey(defaultStart.q, defaultStart.r), { ...newGrid.get(GridUtils.cellKey(defaultStart.q, defaultStart.r)), isStart: true });
    if (newGrid.has(GridUtils.cellKey(defaultEnd.q, defaultEnd.r))) newGrid.set(GridUtils.cellKey(defaultEnd.q, defaultEnd.r), { ...newGrid.get(GridUtils.cellKey(defaultEnd.q, defaultEnd.r)), isEnd: true });
    return newGrid;
  }, [gridType]);

  useEffect(() => {
    const newGrid = initializeGrid();
    setGrid(newGrid);
    const defaultStart = gridType === 'hex' ? { q: -14, r: 0 } : { q: -16, r: 0 };
    const defaultEnd = gridType === 'hex' ? { q: 14, r: 0 } : { q: 16, r: 0 };
    setStartNode(defaultStart); setEndNode(defaultEnd);
    setHasVisualized(false); setFlowVectors(new Map()); setCostField(new Map()); setStats({ visited: 0, pathLength: 0, time: 0 });
    if (!gridConfig.unitSizes.includes(unitSize)) setUnitSize(gridConfig.unitSizes[0]);
    setHeuristic(gridConfig.defaultHeuristic);
  }, [gridType, initializeGrid, gridConfig]);

  const offsetX = SVG_WIDTH / 2, offsetY = SVG_HEIGHT / 2;
  const clearAnimations = useCallback(() => { animationRef.current.forEach(id => clearTimeout(id)); animationRef.current = []; }, []);
  const clearPath = useCallback(() => {
    clearAnimations();
    setGrid(prev => { const newGrid = new Map(prev); for (const [key, node] of newGrid) newGrid.set(key, { ...node, isVisited: false, isPath: false, animationState: 'none' }); return newGrid; });
    setStats({ visited: 0, pathLength: 0, time: 0 }); setFlowVectors(new Map()); setCostField(new Map());
  }, [clearAnimations]);
  const clearBoard = useCallback(() => {
    clearAnimations();
    setGrid(initializeGrid());
    const defaultStart = gridType === 'hex' ? { q: -14, r: 0 } : { q: -16, r: 0 };
    const defaultEnd = gridType === 'hex' ? { q: 14, r: 0 } : { q: 16, r: 0 };
    setStartNode(defaultStart); setEndNode(defaultEnd);
    setHasVisualized(false); setFlowVectors(new Map()); setCostField(new Map()); setStats({ visited: 0, pathLength: 0, time: 0 });
  }, [clearAnimations, initializeGrid, gridType]);

  const reconstructPath = (previous, endKey, startKey, formationState = null) => {
    const path = [];
    let current = endKey;
    while (current && current !== startKey) { path.unshift({ key: current, isCompact: formationState ? (formationState.get(current) ?? true) : true }); current = previous.get(current); }
    if (current === startKey) path.unshift({ key: startKey, isCompact: formationState ? (formationState.get(startKey) ?? true) : true });
    return path;
  };

  const animateAlgorithm = useCallback((visited, path, currentUnitSize = 1) => {
    const { visit: visitDelay, path: pathDelay } = speedSettings[speed];
    visited.forEach((key, index) => {
      const timeout = setTimeout(() => setGrid(prev => { const newGrid = new Map(prev); const node = newGrid.get(key); if (node && !node.isStart && !node.isEnd) newGrid.set(key, { ...node, animationState: 'visited' }); return newGrid; }), index * visitDelay);
      animationRef.current.push(timeout);
    });
    const pathStartTime = visited.length * visitDelay;
    path.forEach((pathNode, index) => {
      const timeout = setTimeout(() => {
        setGrid(prev => {
          const newGrid = new Map(prev);
          const { key, isCompact } = pathNode;
          const { q, r } = GridUtils.parseKey(key);
          const formationCells = GridUtils.getFormationCells(gridType, q, r, currentUnitSize);
          const centerNode = newGrid.get(key);
          if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(key, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
          if (currentUnitSize > 1) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === key) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
          return newGrid;
        });
        if (index === path.length - 1) setIsRunning(false);
      }, pathStartTime + index * pathDelay);
      animationRef.current.push(timeout);
    });
    if (path.length === 0) { const timeout = setTimeout(() => setIsRunning(false), visited.length * visitDelay + 100); animationRef.current.push(timeout); }
  }, [speed, gridType]);

  const runAlgorithm = useCallback(() => {
    if (isRunning) return;
    clearPath(); setIsRunning(true);
    const startTime = performance.now();
    const algorithmGrid = new Map();
    for (const [key, node] of grid) algorithmGrid.set(key, { ...node, isVisited: false });
    const startKey = GridUtils.cellKey(startNode.q, startNode.r);
    let result;
    const runSelectedAlgorithm = (gridToUse, from, to) => {
      switch (selectedAlgorithm) {
        case 'aStar': return Algorithms.aStar(gridToUse, from, to, heuristicWeight >= 10 ? 1000 : heuristicWeight, gridType, heuristic, unitSize, canSnake, snakePenalty);
        case 'dijkstra': return Algorithms.dijkstra(gridToUse, from, to, gridType, unitSize, canSnake, snakePenalty);
        case 'greedyBestFirst': return Algorithms.greedyBestFirst(gridToUse, from, to, gridType, heuristic, unitSize, canSnake, snakePenalty);
        case 'bfs': return Algorithms.bfs(gridToUse, from, to, gridType, unitSize, canSnake);
        case 'dfs': return Algorithms.dfs(gridToUse, from, to, gridType, unitSize, canSnake);
        case 'swarm': return Algorithms.swarm(gridToUse, from, to, gridType, heuristic, unitSize, canSnake, snakePenalty);
        case 'convergentSwarm': return Algorithms.convergentSwarm(gridToUse, from, to, gridType, heuristic, unitSize, canSnake, snakePenalty);
        case 'flowField': return Algorithms.flowField(gridToUse, from, to, gridType, unitSize, canSnake, snakePenalty);
        default: return Algorithms.aStar(gridToUse, from, to, 1, gridType, heuristic, unitSize, canSnake, snakePenalty);
      }
    };
    if (selectedAlgorithm === 'bidirectionalSwarm') {
      const algoResult = Algorithms.bidirectionalSwarm(algorithmGrid, startNode, endNode, gridType, heuristic, unitSize, canSnake, snakePenalty);
      let path = [];
      if (algoResult.meetingPoint) {
        const pathFromStart = reconstructPath(algoResult.previousStart, algoResult.meetingPoint, startKey, algoResult.formationStateStart);
        const pathToEnd = [];
        let current = algoResult.meetingPoint;
        const endKey = GridUtils.cellKey(endNode.q, endNode.r);
        while (current && current !== endKey) { const next = algoResult.previousEnd.get(current); if (next) pathToEnd.push({ key: next, isCompact: algoResult.formationStateEnd?.get(next) ?? true }); current = next; }
        path = [...pathFromStart, ...pathToEnd];
      }
      result = { visited: algoResult.visited, path, gScore: algoResult.gScore };
    } else {
      const algoResult = runSelectedAlgorithm(algorithmGrid, startNode, endNode);
      let path;
      if (selectedAlgorithm === 'flowField' && algoResult.path) { path = algoResult.path; setFlowVectors(algoResult.flowVectors || new Map()); }
      else path = reconstructPath(algoResult.previous, algoResult.endKey, startKey, algoResult.formationState);
      result = { visited: algoResult.visited, path, gScore: selectedAlgorithm === 'flowField' ? (algoResult.costField || new Map()) : (algoResult.gScore || new Map()) };
    }
    if (selectedAlgorithm !== 'flowField') setFlowVectors(new Map());
    setCostField(result.gScore || new Map());
    setStats({ visited: result.visited.length, pathLength: result.path.length, time: Math.round(performance.now() - startTime) });
    animateAlgorithm(result.visited, result.path, unitSize);
    setHasVisualized(true);
  }, [grid, startNode, endNode, selectedAlgorithm, heuristicWeight, unitSize, canSnake, snakePenalty, isRunning, clearPath, animateAlgorithm, gridType, heuristic]);

  const runInstantRecalc = useCallback((gridState, newStart, newEnd) => {
    const algorithmGrid = new Map();
    for (const [k, n] of gridState) algorithmGrid.set(k, { ...n, isVisited: false });
    const sKey = GridUtils.cellKey(newStart.q, newStart.r);
    let path = [], gScore = new Map();
    if (selectedAlgorithm === 'aStar') { const algoResult = Algorithms.aStar(algorithmGrid, newStart, newEnd, heuristicWeight >= 10 ? 1000 : heuristicWeight, gridType, heuristic, unitSize, canSnake, snakePenalty); path = reconstructPath(algoResult.previous, algoResult.endKey, sKey, algoResult.formationState); gScore = algoResult.gScore || new Map(); algoResult.visited.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); }); }
    else if (selectedAlgorithm === 'flowField') { const algoResult = Algorithms.flowField(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake, snakePenalty); path = algoResult.path || []; gScore = algoResult.costField || new Map(); setTimeout(() => setFlowVectors(algoResult.flowVectors || new Map()), 0); }
    else if (selectedAlgorithm === 'bidirectionalSwarm') {
      const algoResult = Algorithms.bidirectionalSwarm(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty);
      gScore = algoResult.gScore || new Map();
      if (algoResult.meetingPoint) { const pathFromStart = reconstructPath(algoResult.previousStart, algoResult.meetingPoint, sKey, algoResult.formationStateStart); const eKey = GridUtils.cellKey(newEnd.q, newEnd.r); const pathToEnd = []; let current = algoResult.meetingPoint; while (current && current !== eKey) { const next = algoResult.previousEnd.get(current); if (next) pathToEnd.push({ key: next, isCompact: algoResult.formationStateEnd?.get(next) ?? true }); current = next; } path = [...pathFromStart, ...pathToEnd]; }
      algoResult.visitedStart?.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); });
      algoResult.visitedEnd?.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); });
    }
    else if (selectedAlgorithm === 'dijkstra') { const algoResult = Algorithms.dijkstra(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake, snakePenalty); path = reconstructPath(algoResult.previous, algoResult.endKey, sKey, algoResult.formationState); gScore = algoResult.gScore || new Map(); algoResult.visited.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); }); }
    else {
      const algoResult = selectedAlgorithm === 'greedyBestFirst' ? Algorithms.greedyBestFirst(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty) : selectedAlgorithm === 'bfs' ? Algorithms.bfs(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake) : selectedAlgorithm === 'dfs' ? Algorithms.dfs(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake) : selectedAlgorithm === 'swarm' ? Algorithms.swarm(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty) : Algorithms.convergentSwarm(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty);
      path = reconstructPath(algoResult.previous, algoResult.endKey, sKey, algoResult.formationState); gScore = algoResult.gScore || new Map(); algoResult.visited.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); });
    }
    return { path, gScore, algorithmGrid };
  }, [selectedAlgorithm, heuristicWeight, unitSize, canSnake, snakePenalty, gridType, heuristic]);

  const handleCellInteraction = useCallback((q, r, isClick = false) => {
    if (isRunning) return;
    const key = GridUtils.cellKey(q, r);
    const node = grid.get(key);
    if (!node) return;
    if (isClick) {
      if (node.isStart) { setIsDragging('start'); return; }
      if (node.isEnd) { setIsDragging('end'); return; }
      const shouldBeWall = !node.isWall;
      setIsDragging('wall'); setWallEditMode(shouldBeWall ? 'add' : 'remove');
      setGrid(prev => { const newGrid = new Map(prev); newGrid.set(key, { ...node, isWall: shouldBeWall }); return newGrid; });
      return;
    }
    if (isDragging === 'start' && !node.isEnd && !node.isWall) {
      const newStart = { q, r };
      setStartNode(newStart);
      const newGrid = new Map(grid);
      for (const [k, n] of newGrid) if (n.isStart && k !== key) newGrid.set(k, { ...n, isStart: false });
      newGrid.set(key, { ...node, isStart: true });
      let newGScore = new Map();
      if (hasVisualized) {
        for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
        const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, newStart, endNode);
        newGScore = gScore;
        for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const pathNode of path) {
          const { key: pKey, isCompact } = pathNode;
          const { q: pq, r: pr } = GridUtils.parseKey(pKey);
          const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize);
          const centerNode = newGrid.get(pKey);
          if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
          if (unitSize > 1) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
        }
        setStats(s => ({ ...s, pathLength: path.length }));
      }
      setGrid(newGrid);
      if (hasVisualized) setCostField(newGScore);
      return;
    }
    if (isDragging === 'end' && !node.isStart && !node.isWall) {
      const newEnd = { q, r };
      setEndNode(newEnd);
      const newGrid = new Map(grid);
      for (const [k, n] of newGrid) if (n.isEnd && k !== key) newGrid.set(k, { ...n, isEnd: false });
      newGrid.set(key, { ...node, isEnd: true });
      let newGScore = new Map();
      if (hasVisualized) {
        for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
        const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, startNode, newEnd);
        newGScore = gScore;
        for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const pathNode of path) {
          const { key: pKey, isCompact } = pathNode;
          const { q: pq, r: pr } = GridUtils.parseKey(pKey);
          const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize);
          const centerNode = newGrid.get(pKey);
          if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
          if (unitSize > 1) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
        }
        setStats(s => ({ ...s, pathLength: path.length }));
      }
      setGrid(newGrid);
      if (hasVisualized) setCostField(newGScore);
      return;
    }
    if (!node.isStart && !node.isEnd && isDragging === 'wall') {
      const shouldBeWall = wallEditMode === 'add';
      if (node.isWall !== shouldBeWall) setGrid(prev => { const newGrid = new Map(prev); newGrid.set(key, { ...node, isWall: shouldBeWall }); return newGrid; });
    }
  }, [grid, isRunning, isDragging, startNode, endNode, hasVisualized, unitSize, runInstantRecalc, wallEditMode, gridType]);

  useEffect(() => {
    const prev = prevSettingsRef.current;
    const settingsChanged = prev.heuristicWeight !== heuristicWeight || prev.snakePenalty !== snakePenalty || prev.canSnake !== canSnake || prev.unitSize !== unitSize || prev.selectedAlgorithm !== selectedAlgorithm || prev.gridType !== gridType || prev.heuristic !== heuristic;
    prevSettingsRef.current = { heuristicWeight, snakePenalty, canSnake, unitSize, selectedAlgorithm, gridType, heuristic };
    if (!settingsChanged || !hasVisualized || isRunning) return;
    let computedGScore = new Map(), computedPathLength = 0;
    setGrid(currentGrid => {
      const newGrid = new Map(currentGrid);
      for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
      const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, startNode, endNode);
      computedGScore = gScore; computedPathLength = path.length;
      for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
      for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
      for (const pathNode of path) {
        const { key: pKey, isCompact } = pathNode;
        const { q: pq, r: pr } = GridUtils.parseKey(pKey);
        const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize);
        const centerNode = newGrid.get(pKey);
        if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
        if (unitSize > 1) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
      }
      return newGrid;
    });
    setCostField(computedGScore); setStats(s => ({ ...s, pathLength: computedPathLength }));
  }, [heuristicWeight, snakePenalty, canSnake, unitSize, selectedAlgorithm, hasVisualized, isRunning, startNode, endNode, runInstantRecalc, gridType, heuristic]);

  const handleMouseDown = (q, r) => handleCellInteraction(q, r, true);
  const handleMouseEnter = (q, r) => { setHoveredHex({ q, r }); if (isDragging) handleCellInteraction(q, r, false); };
  const handleMouseUp = () => { setIsDragging(null); setWallEditMode(null); };
  
  const handleTouchStart = useCallback((e) => {
    if (isRunning) return;
    const touch = e.touches[0];
    const svg = svgRef.current;
    if (!svg) return;
    const rect = svg.getBoundingClientRect();
    const scaleX = SVG_WIDTH / rect.width;
    const scaleY = SVG_HEIGHT / rect.height;
    const x = (touch.clientX - rect.left) * scaleX - offsetX;
    const y = (touch.clientY - rect.top) * scaleY - offsetY;
    const cell = gridType === 'hex' ? GridUtils.axialRound((Math.sqrt(3)/3 * x - 1/3 * y) / CELL_SIZE, (2/3 * y) / CELL_SIZE) : { q: Math.round(x / (CELL_SIZE * 2)), r: Math.round(y / (CELL_SIZE * 2)) };
    const key = GridUtils.cellKey(cell.q, cell.r);
    const node = grid.get(key);
    if (!node) return;
    if (node.isStart) { setIsDragging('start'); e.preventDefault(); }
    else if (node.isEnd) { setIsDragging('end'); e.preventDefault(); }
    else { setIsDragging('wall'); setWallEditMode(!node.isWall ? 'add' : 'remove'); setGrid(prev => { const newGrid = new Map(prev); newGrid.set(key, { ...node, isWall: !node.isWall }); return newGrid; }); e.preventDefault(); }
  }, [grid, isRunning, gridType, CELL_SIZE, offsetX, offsetY]);

  const handleTouchMove = useCallback((e) => {
    if (!isDragging || isRunning) return;
    const touch = e.touches[0];
    const svg = svgRef.current;
    if (!svg) return;
    const rect = svg.getBoundingClientRect();
    const scaleX = SVG_WIDTH / rect.width;
    const scaleY = SVG_HEIGHT / rect.height;
    const x = (touch.clientX - rect.left) * scaleX - offsetX;
    const y = (touch.clientY - rect.top) * scaleY - offsetY;
    const cell = gridType === 'hex' ? GridUtils.axialRound((Math.sqrt(3)/3 * x - 1/3 * y) / CELL_SIZE, (2/3 * y) / CELL_SIZE) : { q: Math.round(x / (CELL_SIZE * 2)), r: Math.round(y / (CELL_SIZE * 2)) };
    handleCellInteraction(cell.q, cell.r, false);
    e.preventDefault();
  }, [isDragging, isRunning, gridType, CELL_SIZE, offsetX, offsetY, handleCellInteraction]);

  const handleTouchEnd = useCallback(() => { setIsDragging(null); setWallEditMode(null); }, []);
  const generateMaze = useCallback(() => { clearPath(); setHasVisualized(false); setGrid(prev => { const newGrid = new Map(prev); for (const [key, node] of newGrid) if (!node.isStart && !node.isEnd) newGrid.set(key, { ...node, isWall: Math.random() < 0.3 }); return newGrid; }); }, [clearPath]);
  const isInStartFormation = useCallback((q, r) => { if (unitSize === 1) return q === startNode.q && r === startNode.r; return GridUtils.getFormationCells(gridType, startNode.q, startNode.r, unitSize).some(c => c.q === q && c.r === r); }, [startNode, unitSize, gridType]);
  const isInEndFormation = useCallback((q, r) => { if (unitSize === 1) return q === endNode.q && r === endNode.r; return GridUtils.getFormationCells(gridType, endNode.q, endNode.r, unitSize).some(c => c.q === q && c.r === r); }, [endNode, unitSize, gridType]);
  const getCellFill = (node) => { const inStart = isInStartFormation(node.q, node.r), inEnd = isInEndFormation(node.q, node.r); if (inStart) return '#0077BB'; if (inEnd) return '#EE7733'; if (node.isWall) return '#0d0d1a'; switch (node.animationState) { case 'visited': return '#88CCEE'; case 'path': case 'pathFormation': return '#FFDD44'; case 'pathSnaking': case 'pathSnakingFormation': return '#FFFFFF'; default: break; } return '#1a1a2e'; };
  const getCellStroke = (node, isHovered) => { if (isHovered) return '#fff'; const inStart = isInStartFormation(node.q, node.r), inEnd = isInEndFormation(node.q, node.r); if (inStart) return '#0077BB'; if (inEnd) return '#EE7733'; if (node.isWall) return '#333'; return '#0f3460'; };
  const getFlowArrow = (q, r, direction) => { const { x, y } = GridUtils.cellToPixel(gridType, q, r, CELL_SIZE); const cx = x + offsetX, cy = y + offsetY; const targetPixel = GridUtils.cellToPixel(gridType, q + direction.q, r + direction.r, CELL_SIZE); const angle = Math.atan2(targetPixel.y - y, targetPixel.x - x); const arrowLength = CELL_SIZE * 0.5, arrowHeadSize = CELL_SIZE * 0.2; const startX = cx - Math.cos(angle) * (arrowLength * 0.3), startY = cy - Math.sin(angle) * (arrowLength * 0.3); const tipX = cx + Math.cos(angle) * arrowLength * 0.7, tipY = cy + Math.sin(angle) * arrowLength * 0.7; const headAngle1 = angle + Math.PI * 0.75, headAngle2 = angle - Math.PI * 0.75; return { line: { x1: startX, y1: startY, x2: tipX, y2: tipY }, head: `${tipX},${tipY} ${tipX + Math.cos(headAngle1) * arrowHeadSize},${tipY + Math.sin(headAngle1) * arrowHeadSize} ${tipX + Math.cos(headAngle2) * arrowHeadSize},${tipY + Math.sin(headAngle2) * arrowHeadSize}` }; };

  const renderCell = (node) => {
    const { x, y } = GridUtils.cellToPixel(gridType, node.q, node.r, CELL_SIZE);
    const cx = x + offsetX, cy = y + offsetY;
    const isHovered = hoveredHex && hoveredHex.q === node.q && hoveredHex.r === node.r;
    const inStart = isInStartFormation(node.q, node.r), inEnd = isInEndFormation(node.q, node.r);
    const isPrimaryStart = node.q === startNode.q && node.r === startNode.r, isPrimaryEnd = node.q === endNode.q && node.r === endNode.r;
    const cellKey = GridUtils.cellKey(node.q, node.r);
    const flowVector = flowVectors.get(cellKey);
    const arrow = showFlowVectors && flowVector ? getFlowArrow(node.q, node.r, flowVector.direction) : null;
    const cellCost = costField.get(cellKey);
    const isPathCell = ['path', 'pathFormation', 'pathSnaking', 'pathSnakingFormation'].includes(node.animationState);
    const showCost = showCostOverlay && cellCost !== undefined && (node.animationState === 'visited' || isPathCell);
    const costTextColor = isPathCell ? '#000' : '#fff';
    const isOnPath = node.animationState === 'path' || node.animationState === 'pathFormation';
    const arrowColor = isOnPath ? '#000' : '#1a237e', arrowStroke = isOnPath ? '#FFDD44' : '#fff';

    if (gridType === 'hex') {
      const corners = GridUtils.hexCorners(cx, cy, CELL_SIZE - 1);
      return (
        <g key={cellKey}>
          <polygon points={corners.map(c => `${c.x},${c.y}`).join(' ')} fill={getCellFill(node)} stroke={getCellStroke(node, isHovered)} strokeWidth={isHovered ? 2 : (inStart || inEnd) && unitSize > 1 ? 2 : 1} onMouseDown={() => handleMouseDown(node.q, node.r)} onMouseEnter={() => handleMouseEnter(node.q, node.r)} style={{ cursor: 'pointer' }} />
          {isPrimaryStart && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="14" fontWeight="bold" pointerEvents="none">â–¶</text>}
          {isPrimaryEnd && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="14" fontWeight="bold" pointerEvents="none">â—Ž</text>}
          {showCellNumbers && <text x={cx} y={cy + (isPrimaryStart || isPrimaryEnd ? 8 : 0)} textAnchor="middle" dominantBaseline="central" fill="#666" fontSize="7" pointerEvents="none">{node.q},{node.r}</text>}
          {showCost && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill={costTextColor} fontSize="8" fontWeight="bold" pointerEvents="none" style={{ textShadow: isPathCell ? '0 0 2px #fff' : '0 0 3px #000' }}>{cellCost.toFixed(1)}</text>}
          {arrow && <><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowStroke} strokeWidth="2" pointerEvents="none" /><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowColor} strokeWidth="1" pointerEvents="none" /><polygon points={arrow.head} fill={arrowColor} stroke={arrowStroke} strokeWidth="0.5" pointerEvents="none" /></>}
        </g>
      );
    } else {
      const halfSize = CELL_SIZE - 1;
      return (
        <g key={cellKey}>
          <rect x={cx - halfSize} y={cy - halfSize} width={halfSize * 2} height={halfSize * 2} fill={getCellFill(node)} stroke={getCellStroke(node, isHovered)} strokeWidth={isHovered ? 2 : (inStart || inEnd) && unitSize > 1 ? 2 : 1} onMouseDown={() => handleMouseDown(node.q, node.r)} onMouseEnter={() => handleMouseEnter(node.q, node.r)} style={{ cursor: 'pointer' }} />
          {isPrimaryStart && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="12" fontWeight="bold" pointerEvents="none">â–¶</text>}
          {isPrimaryEnd && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="12" fontWeight="bold" pointerEvents="none">â—Ž</text>}
          {showCellNumbers && <text x={cx} y={cy + (isPrimaryStart || isPrimaryEnd ? 6 : 0)} textAnchor="middle" dominantBaseline="central" fill="#666" fontSize="6" pointerEvents="none">{node.q},{node.r}</text>}
          {showCost && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill={costTextColor} fontSize="7" fontWeight="bold" pointerEvents="none" style={{ textShadow: isPathCell ? '0 0 2px #fff' : '0 0 3px #000' }}>{cellCost.toFixed(1)}</text>}
          {arrow && <><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowStroke} strokeWidth="2" pointerEvents="none" /><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowColor} strokeWidth="1" pointerEvents="none" /><polygon points={arrow.head} fill={arrowColor} stroke={arrowStroke} strokeWidth="0.5" pointerEvents="none" /></>}
        </g>
      );
    }
  };

  const getHeuristicLabel = (h) => { switch (h) { case 'hex': return 'Hex Distance'; case 'manhattan': return 'Manhattan'; case 'chebyshev': return 'Chebyshev'; case 'euclidean': return 'Euclidean'; default: return h; } };

  return (
    <div style={{ fontFamily: 'system-ui, -apple-system, sans-serif', background: '#0a0a1a', minHeight: '100vh', color: '#e8e8e8' }}>
      <nav style={{ background: 'linear-gradient(90deg, #1a1a2e, #16213e)', padding: '12px 16px', display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', borderBottom: '1px solid #0f3460', WebkitOverflowScrolling: 'touch', position: 'relative', zIndex: 100, overflow: 'visible' }}>
        <h1 style={{ margin: 0, fontSize: '18px', fontWeight: 700, background: 'linear-gradient(90deg, #64b5f6, #ffc107)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', marginRight: '16px' }}>â¬¡ Pathfinding Visualizer</h1>
        <select value={gridType} onChange={(e) => setGridType(e.target.value)} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}><option value="hex">Hex Grid (6-dir)</option><option value="square4">Square (4-dir)</option><option value="square8">Square (8-dir)</option></select>
        <div ref={algorithmDropdownRef} style={{ position: 'relative', zIndex: 1000 }}>
          <button onClick={() => !isRunning && setAlgorithmDropdownOpen(!algorithmDropdownOpen)} disabled={isRunning}
            style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '8px', minWidth: '220px', justifyContent: 'space-between' }}>
            <span style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
              <span>{algorithmInfo[selectedAlgorithm].icon}</span>
              <span>{algorithmInfo[selectedAlgorithm].name}</span>
              <span style={{ fontSize: '9px', padding: '2px 5px', borderRadius: '3px', background: algorithmInfo[selectedAlgorithm].optimal === true ? 'rgba(76, 175, 80, 0.3)' : algorithmInfo[selectedAlgorithm].optimal ? 'rgba(255, 193, 7, 0.3)' : 'rgba(238, 119, 51, 0.3)', color: algorithmInfo[selectedAlgorithm].optimal === true ? '#4caf50' : algorithmInfo[selectedAlgorithm].optimal ? '#ffc107' : '#EE7733' }}>
                {algorithmInfo[selectedAlgorithm].optimal === true ? 'âœ“ Optimal' : algorithmInfo[selectedAlgorithm].optimal ? `âœ“ ${algorithmInfo[selectedAlgorithm].optimal}` : 'âœ— Suboptimal'}
              </span>
            </span>
            <span style={{ fontSize: '10px', marginLeft: '4px' }}>â–¼</span>
          </button>
          {algorithmDropdownOpen && (
            <div style={{ position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: '#1a1a2e', border: '1px solid #0f3460', borderRadius: '8px', boxShadow: '0 8px 32px rgba(0,0,0,0.8)', zIndex: 9999, minWidth: '340px', overflow: 'hidden' }}>
              {Object.entries(algorithmInfo).map(([key, info]) => (
                <div key={key} onClick={() => { setSelectedAlgorithm(key); setAlgorithmDropdownOpen(false); }}
                  style={{ padding: '10px 14px', cursor: 'pointer', background: selectedAlgorithm === key ? 'rgba(100, 181, 246, 0.2)' : 'transparent', borderLeft: selectedAlgorithm === key ? '3px solid #64b5f6' : '3px solid transparent' }}
                  onMouseEnter={(e) => { if (selectedAlgorithm !== key) e.currentTarget.style.background = 'rgba(100, 181, 246, 0.1)'; }}
                  onMouseLeave={(e) => { e.currentTarget.style.background = selectedAlgorithm === key ? 'rgba(100, 181, 246, 0.2)' : 'transparent'; }}>
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '3px' }}>
                    <span style={{ display: 'flex', alignItems: 'center', gap: '8px', fontWeight: 500, color: '#e8e8e8' }}>
                      <span>{info.icon}</span><span>{info.name}</span>
                    </span>
                    <div style={{ display: 'flex', gap: '6px' }}>
                      <span style={{ fontSize: '10px', padding: '2px 6px', borderRadius: '3px', background: info.optimal === true ? 'rgba(76, 175, 80, 0.3)' : info.optimal ? 'rgba(255, 193, 7, 0.3)' : 'rgba(238, 119, 51, 0.3)', color: info.optimal === true ? '#4caf50' : info.optimal ? '#ffc107' : '#EE7733' }}>
                        {info.optimal === true ? 'âœ“ Optimal' : info.optimal ? `âœ“ ${info.optimal}` : 'âœ— Suboptimal'}
                      </span>
                      {!info.complete && <span style={{ fontSize: '10px', padding: '2px 6px', borderRadius: '3px', background: 'rgba(238, 119, 51, 0.3)', color: '#EE7733' }}>Incomplete</span>}
                    </div>
                  </div>
                  <div style={{ fontSize: '11px', color: '#90a4ae', paddingLeft: '26px' }}>{info.desc}</div>
                </div>
              ))}
            </div>
          )}
        </div>
        {['aStar', 'greedyBestFirst', 'swarm', 'convergentSwarm', 'bidirectionalSwarm'].includes(selectedAlgorithm) && <select value={heuristic} onChange={(e) => setHeuristic(e.target.value)} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{gridConfig.heuristics.map(h => <option key={h} value={h}>{getHeuristicLabel(h)}</option>)}</select>}
        {selectedAlgorithm === 'aStar' && <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(100, 181, 246, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #1e88e5' }}><span style={{ fontSize: '10px', color: '#90a4ae' }}>w:</span><input type="range" min="0" max="10" step="0.1" value={heuristicWeight} onChange={(e) => setHeuristicWeight(parseFloat(e.target.value))} disabled={isRunning} style={{ width: '80px', cursor: isRunning ? 'not-allowed' : 'pointer', accentColor: '#88CCEE' }} /><span style={{ fontSize: '11px', fontWeight: 'bold', color: heuristicWeight <= 1 ? '#88CCEE' : heuristicWeight < 3 ? '#DDAA00' : '#EE7733', minWidth: '30px' }}>{heuristicWeight >= 10 ? 'âˆž' : heuristicWeight.toFixed(1)}</span></div>}
        <button onClick={runAlgorithm} disabled={isRunning} style={{ background: 'linear-gradient(90deg, #0077BB, #88CCEE)', color: '#fff', border: 'none', borderRadius: '4px', padding: '8px 20px', cursor: isRunning ? 'not-allowed' : 'pointer', fontWeight: 600, fontSize: '14px', boxShadow: '0 2px 8px rgba(0, 119, 187, 0.4)' }}>{isRunning ? 'Running...' : 'Visualize!'}</button>
        <button onClick={clearPath} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px' }}>Clear Path</button>
        <button onClick={clearBoard} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px' }}>Clear Board</button>
        <select value={speed} onChange={(e) => setSpeed(e.target.value)} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}><option value="fast">Fast</option><option value="average">Medium</option><option value="slow">Slow</option></select>
      </nav>
      <nav style={{ background: 'rgba(15, 52, 96, 0.8)', padding: '8px 16px', display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', borderBottom: '1px solid #0f3460', overflowX: 'auto', WebkitOverflowScrolling: 'touch', position: 'relative', zIndex: 50 }}>
        <button onClick={generateMaze} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px' }}>Random Walls</button>
        <div style={{ width: '1px', height: '24px', background: '#0f3460' }} />
        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(170, 68, 153, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #AA4499' }}><span style={{ fontSize: '12px', color: '#AA4499' }}>Unit:</span>{gridConfig.unitSizes.map(size => <button key={size} onClick={() => setUnitSize(size)} disabled={isRunning} style={{ background: unitSize === size ? '#AA4499' : '#16213e', color: '#e8e8e8', border: `1px solid ${unitSize === size ? '#AA4499' : '#0f3460'}`, borderRadius: '4px', padding: '4px 8px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '11px', fontWeight: unitSize === size ? 'bold' : 'normal' }}>{gridConfig.unitLabels[size]}</button>)}</div>
        <div style={{ width: '100px', display: 'flex', justifyContent: 'center' }}>{unitSize > 1 ? <button onClick={() => setCanSnake(!canSnake)} disabled={isRunning} style={{ background: canSnake ? '#DDAA00' : '#16213e', color: canSnake ? '#000' : '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px', fontWeight: canSnake ? 'bold' : 'normal', width: '100%' }}>{canSnake ? 'ðŸ Snake âœ“' : 'ðŸ Snake'}</button> : <span style={{ color: '#455a64', fontSize: '11px' }}>(1-unit)</span>}</div>
        {unitSize > 1 && canSnake && <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(221, 170, 0, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #DDAA00' }}><span style={{ fontSize: '11px', color: '#DDAA00' }}>Cost:</span><input type="range" min="0" max="10" step="0.5" value={snakePenalty} onChange={(e) => setSnakePenalty(parseFloat(e.target.value))} disabled={isRunning} style={{ width: '60px', cursor: isRunning ? 'not-allowed' : 'pointer', accentColor: '#DDAA00' }} /><span style={{ fontSize: '11px', fontWeight: 'bold', color: '#DDAA00' }}>{snakePenalty.toFixed(1)}</span></div>}
        <div style={{ width: '1px', height: '24px', background: '#0f3460' }} />
        <button onClick={() => setShowCellNumbers(!showCellNumbers)} style={{ background: showCellNumbers ? '#2196f3' : '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{showCellNumbers ? 'ðŸ”¢ Coords âœ“' : 'ðŸ”¢ Coords'}</button>
        <button onClick={() => { setShowCostOverlay(!showCostOverlay); if (!showCostOverlay && selectedAlgorithm === 'flowField') setShowFlowVectors(false); }} style={{ background: showCostOverlay ? '#e91e63' : '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{showCostOverlay ? 'ðŸ’° Costs âœ“' : 'ðŸ’° Costs'}</button>
        {selectedAlgorithm === 'flowField' && <button onClick={() => { setShowFlowVectors(!showFlowVectors); if (!showFlowVectors) setShowCostOverlay(false); }} style={{ background: showFlowVectors ? '#00bcd4' : '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{showFlowVectors ? 'â†’ Arrows âœ“' : 'â†’ Arrows'}</button>}
      </nav>
      <div style={{ background: 'rgba(22, 33, 62, 0.9)', padding: '8px 16px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '12px', borderBottom: '1px solid #0f3460', fontSize: '12px', position: 'relative', zIndex: 10 }}>
        <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#0077BB', borderRadius: 2 }}></span> Start</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#EE7733', borderRadius: 2 }}></span> Target</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#0d0d1a', borderRadius: 2, border: '1px solid #333' }}></span> Wall</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#88CCEE', borderRadius: 2 }}></span> Visited</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#FFDD44', borderRadius: 2 }}></span> Path</span></div>
        <div style={{ display: 'flex', gap: '16px' }}><span>Visited: <strong style={{ color: '#88CCEE' }}>{stats.visited}</strong></span><span>Path: <strong style={{ color: '#FFDD44' }}>{stats.pathLength}</strong></span><span>Time: <strong style={{ color: '#ffc107' }}>{stats.time}ms</strong></span></div>
      </div>
      <div className="grid-container" style={{ display: 'flex', justifyContent: 'center', padding: '10px', background: '#0a0a1a', userSelect: 'none', overflow: 'auto', WebkitOverflowScrolling: 'touch', position: 'relative', zIndex: 1 }}><svg ref={svgRef} width={SVG_WIDTH} height={SVG_HEIGHT} viewBox={`0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`} style={{ background: '#0d0d1a', borderRadius: '8px', userSelect: 'none', flexShrink: 0, touchAction: isDragging ? 'none' : 'pan-x pan-y' }} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd} onDragStart={(e) => e.preventDefault()}>{Array.from(grid.values()).map(node => renderCell(node))}</svg></div>
      
      {/* Formula Display */}
      <div style={{ background: 'linear-gradient(180deg, #0d1520, #0a0a1a)', padding: '20px', borderTop: '1px solid #0f3460' }}>
        <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
          <h3 style={{ color: '#64b5f6', marginBottom: '16px', fontSize: '16px', display: 'flex', alignItems: 'center', gap: '8px' }}>
            ðŸ“ Algorithm: <span style={{ color: '#FFDD44' }}>{
              selectedAlgorithm === 'aStar' ? 'A* Search' :
              selectedAlgorithm === 'dijkstra' ? "Dijkstra's Algorithm" :
              selectedAlgorithm === 'greedyBestFirst' ? 'Greedy Best-First Search' :
              selectedAlgorithm === 'bfs' ? 'Breadth-First Search (BFS)' :
              selectedAlgorithm === 'dfs' ? 'Depth-First Search (DFS)' :
              selectedAlgorithm === 'swarm' ? 'Swarm Algorithm' :
              selectedAlgorithm === 'convergentSwarm' ? 'Convergent Swarm' :
              selectedAlgorithm === 'bidirectionalSwarm' ? 'Bidirectional Swarm' :
              selectedAlgorithm === 'flowField' ? 'Flow Field' : selectedAlgorithm
            }</span>
          </h3>
          
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '20px' }}>
            {/* Core Formula */}
            <div style={{ background: 'rgba(100, 181, 246, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #1e88e5' }}>
              <h4 style={{ color: '#90caf9', marginBottom: '12px', fontSize: '14px' }}>Core Formula</h4>
              <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                {selectedAlgorithm === 'aStar' && <>f(n) = g(n) + w Ã— h(n)</>}
                {selectedAlgorithm === 'dijkstra' && <>f(n) = g(n)</>}
                {selectedAlgorithm === 'greedyBestFirst' && <>f(n) = h(n)</>}
                {selectedAlgorithm === 'bfs' && <>Queue: FIFO order</>}
                {selectedAlgorithm === 'dfs' && <>Stack: LIFO order</>}
                {selectedAlgorithm === 'swarm' && <>f(n) = g(n) + w(i) Ã— h(n)<br/>w(i) = 1 + (h/i) Ã— 2</>}
                {selectedAlgorithm === 'convergentSwarm' && <>f(n) = g(n) + w(p) Ã— h(n)<br/>w(p) = 1 + (1 - p) Ã— 3</>}
                {selectedAlgorithm === 'bidirectionalSwarm' && <>Forward: f(n) = g(n) + h(nâ†’end)<br/>Backward: f(n) = g(n) + h(nâ†’start)</>}
                {selectedAlgorithm === 'flowField' && <>cost(n) = min(cost(neighbors)) + move_cost</>}
              </div>
              <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                {selectedAlgorithm === 'aStar' && <>
                  <div><strong style={{ color: '#88CCEE' }}>f(n)</strong> = total estimated cost through node n</div>
                  <div><strong style={{ color: '#88CCEE' }}>g(n)</strong> = actual cost from start to n</div>
                  <div><strong style={{ color: '#88CCEE' }}>h(n)</strong> = heuristic estimate from n to goal</div>
                  <div><strong style={{ color: '#88CCEE' }}>w</strong> = heuristic weight ({heuristicWeight >= 10 ? 'âˆž' : heuristicWeight.toFixed(1)}) â€” higher values favor speed over optimality</div>
                </>}
                {selectedAlgorithm === 'dijkstra' && <>
                  <div><strong style={{ color: '#88CCEE' }}>f(n)</strong> = priority for expansion</div>
                  <div><strong style={{ color: '#88CCEE' }}>g(n)</strong> = actual cost from start to n</div>
                  <div>No heuristic â€” explores uniformly in all directions</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>âœ“ Guarantees optimal path</div>
                </>}
                {selectedAlgorithm === 'greedyBestFirst' && <>
                  <div><strong style={{ color: '#88CCEE' }}>f(n)</strong> = priority based purely on heuristic</div>
                  <div><strong style={{ color: '#88CCEE' }}>h(n)</strong> = estimated distance to goal</div>
                  <div>Ignores path cost â€” very fast but may find suboptimal paths</div>
                  <div style={{ color: '#EE7733', marginTop: '4px' }}>âš  Does not guarantee optimal path</div>
                </>}
                {selectedAlgorithm === 'bfs' && <>
                  <div>Explores nodes level-by-level using a <strong style={{ color: '#88CCEE' }}>queue</strong></div>
                  <div>First-In-First-Out: oldest discovered nodes explored first</div>
                  <div>Treats all edges as equal cost</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>âœ“ Guarantees shortest path (by hop count)</div>
                </>}
                {selectedAlgorithm === 'dfs' && <>
                  <div>Explores as deep as possible using a <strong style={{ color: '#88CCEE' }}>stack</strong></div>
                  <div>Last-In-First-Out: most recent nodes explored first</div>
                  <div>Memory efficient but unpredictable path quality</div>
                  <div style={{ color: '#EE7733', marginTop: '4px' }}>âš  Usually finds suboptimal paths</div>
                </>}
                {selectedAlgorithm === 'swarm' && <>
                  <div><strong style={{ color: '#88CCEE' }}>w(i)</strong> = dynamic weight based on iteration count</div>
                  <div><strong style={{ color: '#88CCEE' }}>i</strong> = current iteration number</div>
                  <div>Early: high heuristic weight (greedy) â†’ Late: balanced</div>
                  <div style={{ color: '#AA4499', marginTop: '4px' }}>Mimics swarm behavior converging on target</div>
                </>}
                {selectedAlgorithm === 'convergentSwarm' && <>
                  <div><strong style={{ color: '#88CCEE' }}>w(p)</strong> = weight based on progress toward goal</div>
                  <div><strong style={{ color: '#88CCEE' }}>p</strong> = progress ratio (0 = at start, 1 = at goal)</div>
                  <div>Far from goal: greedy â†’ Near goal: careful</div>
                  <div style={{ color: '#AA4499', marginTop: '4px' }}>Accelerates then refines approach</div>
                </>}
                {selectedAlgorithm === 'bidirectionalSwarm' && <>
                  <div>Two simultaneous searches from start and end</div>
                  <div>Searches meet in the middle and merge paths</div>
                  <div>Can dramatically reduce search space</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>âœ“ Often faster than unidirectional search</div>
                </>}
                {selectedAlgorithm === 'flowField' && <>
                  <div>Computes <strong style={{ color: '#88CCEE' }}>cost field</strong> from goal outward</div>
                  <div>Each cell stores direction to lowest-cost neighbor</div>
                  <div>Any unit can follow arrows to reach goal</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>âœ“ Efficient for many units with same destination</div>
                </>}
              </div>
            </div>

            {/* Heuristic Function */}
            <div style={{ background: 'rgba(170, 68, 153, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #AA4499' }}>
              <h4 style={{ color: '#ce93d8', marginBottom: '12px', fontSize: '14px' }}>Heuristic: {getHeuristicLabel(heuristic)}</h4>
              <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                {heuristic === 'hex' && <>h = max(|Î”x|, |Î”y|, |Î”z|)<br/><span style={{ fontSize: '12px', color: '#b0bec5' }}>where x+y+z=0 (cube coords)</span></>}
                {heuristic === 'manhattan' && <>h = |xâ‚ - xâ‚‚| + |yâ‚ - yâ‚‚|</>}
                {heuristic === 'chebyshev' && <>h = max(|xâ‚ - xâ‚‚|, |yâ‚ - yâ‚‚|)</>}
                {heuristic === 'euclidean' && <>h = âˆš((xâ‚-xâ‚‚)Â² + (yâ‚-yâ‚‚)Â²)</>}
              </div>
              <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                {heuristic === 'hex' && <>
                  <div>Converts axial (q,r) to cube coordinates (x,y,z)</div>
                  <div>Cube constraint: x + y + z = 0</div>
                  <div>Distance = maximum absolute difference</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>âœ“ Exact distance for hex grids</div>
                </>}
                {heuristic === 'manhattan' && <>
                  <div>Sum of horizontal and vertical distances</div>
                  <div>Also called "taxicab" or "L1" distance</div>
                  <div>Assumes only cardinal (4-directional) movement</div>
                  <div style={{ color: gridType === 'square4' ? '#FFDD44' : '#EE7733', marginTop: '4px' }}>
                    {gridType === 'square4' ? 'âœ“ Optimal for 4-directional grids' : 'âš  Overestimates for diagonal movement'}
                  </div>
                </>}
                {heuristic === 'chebyshev' && <>
                  <div>Maximum of horizontal or vertical distance</div>
                  <div>Also called "chessboard" distance</div>
                  <div>Assumes diagonal moves cost same as cardinal</div>
                  <div style={{ color: gridType === 'square8' ? '#FFDD44' : '#EE7733', marginTop: '4px' }}>
                    {gridType === 'square8' ? 'âœ“ Good for 8-directional grids' : 'âš  May underestimate without diagonals'}
                  </div>
                </>}
                {heuristic === 'euclidean' && <>
                  <div>Straight-line distance (Pythagorean theorem)</div>
                  <div>Most accurate real-world distance</div>
                  <div>Never overestimates (admissible)</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>âœ“ Admissible for any grid type</div>
                </>}
              </div>
            </div>

            {/* Movement Cost */}
            <div style={{ background: 'rgba(238, 119, 51, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #EE7733' }}>
              <h4 style={{ color: '#ffab91', marginBottom: '12px', fontSize: '14px' }}>Movement Cost</h4>
              <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                {gridType === 'hex' && <>cost = 1.0 per hex</>}
                {gridType === 'square4' && <>cost = 1.0 per cell</>}
                {gridType === 'square8' && <>cardinal = 1.0<br/>diagonal = âˆš2 â‰ˆ 1.414</>}
              </div>
              <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                {gridType === 'hex' && <>
                  <div>All 6 hex directions have equal cost</div>
                  <div>Hex grids have uniform distance in all directions</div>
                  <div>No diagonal penalty needed</div>
                </>}
                {gridType === 'square4' && <>
                  <div>4 cardinal directions: â†‘ â†“ â† â†’</div>
                  <div>Each step costs 1.0 unit</div>
                  <div>No diagonal movement allowed</div>
                </>}
                {gridType === 'square8' && <>
                  <div>8 directions: cardinals + diagonals</div>
                  <div>Diagonal = âˆš(1Â² + 1Â²) = âˆš2 â‰ˆ 1.414</div>
                  <div>Accurate Euclidean movement costs</div>
                </>}
              </div>
            </div>

            {/* Formation/Snake Info - only show if unit size > 1 */}
            {unitSize > 1 && (
              <div style={{ background: 'rgba(221, 170, 0, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #DDAA00' }}>
                <h4 style={{ color: '#ffeb3b', marginBottom: '12px', fontSize: '14px' }}>Formation: {gridConfig.unitLabels[unitSize]}</h4>
                <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                  clearance_cost = blocked_neighbors Ã— 0.1
                  {canSnake && <><br/>snake_cost = {snakePenalty.toFixed(1)} (first) | {(snakePenalty * 0.15).toFixed(2)} (cont.)</>}
                </div>
                <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                  <div><strong style={{ color: '#DDAA00' }}>Formation cells:</strong> {unitSize} cells move together</div>
                  <div><strong style={{ color: '#DDAA00' }}>Clearance penalty:</strong> prefers open spaces</div>
                  {canSnake ? <>
                    <div><strong style={{ color: '#DDAA00' }}>Snake mode:</strong> enabled</div>
                    <div>â€¢ First snake move: +{snakePenalty.toFixed(1)} cost</div>
                    <div>â€¢ Continued snaking: +{(snakePenalty * 0.15).toFixed(2)} cost</div>
                    <div>â€¢ Reforming bonus: +{(snakePenalty * 0.3).toFixed(2)} cost</div>
                    <div style={{ color: '#fff', marginTop: '4px' }}>White path = snaking through tight spaces</div>
                  </> : <>
                    <div><strong style={{ color: '#DDAA00' }}>Snake mode:</strong> disabled</div>
                    <div>Formation must fit completely in all spaces</div>
                  </>}
                </div>
              </div>
            )}
          </div>

          {/* Algorithm Characteristics */}
          <div style={{ marginTop: '20px', padding: '16px', background: 'rgba(136, 204, 238, 0.1)', borderRadius: '8px', border: '1px solid #0f3460' }}>
            <h4 style={{ color: '#88CCEE', marginBottom: '12px', fontSize: '14px' }}>Algorithm Characteristics</h4>
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '16px', fontSize: '12px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Optimal:</span>
                <span style={{ color: ['dijkstra', 'bfs'].includes(selectedAlgorithm) || (selectedAlgorithm === 'aStar' && heuristicWeight <= 1) ? '#4caf50' : '#EE7733', fontWeight: 'bold' }}>
                  {['dijkstra', 'bfs'].includes(selectedAlgorithm) || (selectedAlgorithm === 'aStar' && heuristicWeight <= 1) ? 'Yes' : selectedAlgorithm === 'aStar' ? 'wâ‰¤1 only' : 'No'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Complete:</span>
                <span style={{ color: selectedAlgorithm === 'dfs' ? '#EE7733' : '#4caf50', fontWeight: 'bold' }}>
                  {selectedAlgorithm === 'dfs' ? 'No (may loop)' : 'Yes'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Time Complexity:</span>
                <span style={{ color: '#88CCEE', fontFamily: 'monospace' }}>
                  {selectedAlgorithm === 'dijkstra' ? 'O((V+E) log V)' :
                   selectedAlgorithm === 'aStar' ? 'O(b^d) worst' :
                   selectedAlgorithm === 'bfs' ? 'O(V + E)' :
                   selectedAlgorithm === 'dfs' ? 'O(V + E)' :
                   selectedAlgorithm === 'flowField' ? 'O(V log V)' :
                   'O(b^d)'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Space:</span>
                <span style={{ color: '#88CCEE', fontFamily: 'monospace' }}>
                  {selectedAlgorithm === 'dfs' ? 'O(d)' :
                   selectedAlgorithm === 'flowField' ? 'O(V)' :
                   'O(V)'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Data Structure:</span>
                <span style={{ color: '#ce93d8' }}>
                  {selectedAlgorithm === 'bfs' ? 'Queue (FIFO)' :
                   selectedAlgorithm === 'dfs' ? 'Stack (LIFO)' :
                   'Priority Queue (Min-Heap)'}
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<PathfindingVisualizer />);
  </script>
</body>
</html>
