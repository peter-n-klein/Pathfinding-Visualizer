<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pathfinding Visualizer</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a1a; }
    /* Hide scrollbar but allow scrolling */
    nav::-webkit-scrollbar, .grid-container::-webkit-scrollbar { display: none; }
    nav, .grid-container { -ms-overflow-style: none; scrollbar-width: none; }
    @media (max-width: 768px) {
      nav { flex-wrap: nowrap !important; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useRef, useCallback, useEffect } = React;

const GridUtils = {
  CONFIGS: {
    hex: {
      directions: [
        { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
        { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 },
      ],
      formations: {
        1: [{ q: 0, r: 0 }],
        3: [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: 0, r: 1 }],
        7: [
          { q: 0, r: 0 }, { q: 1, r: 0 }, { q: 1, r: -1 },
          { q: 0, r: -1 }, { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
        ],
      },
      // Oblong formations - line formations with orientations
      oblongFormations: {
        '3L': {
          orientations: [
            // Orientation 0: along q-axis (E-W line)
            [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: -1, r: 0 }],
            // Orientation 1: along r-axis (NW-SE line when r changes)
            [{ q: 0, r: 0 }, { q: 0, r: 1 }, { q: 0, r: -1 }],
            // Orientation 2: along third axis (NE-SW diagonal)
            [{ q: 0, r: 0 }, { q: 1, r: -1 }, { q: -1, r: 1 }],
          ],
          // Perpendicular = directions that move the whole line forward (march direction)
          // Parallel = directions along the line (sidestep)
          perpendicularDirs: [
            [1, 2, 4, 5], // Orientation 0 (E-W line): march NE, NW, SW, SE
            [0, 1, 3, 4], // Orientation 1 (NW-SE line): march E, NE, W, SW
            [0, 2, 3, 5], // Orientation 2 (NE-SW line): march E, NW, W, SE
          ],
          parallelDirs: [
            [0, 3], // Orientation 0: sidestep E, W
            [2, 5], // Orientation 1: sidestep NW, SE
            [1, 4], // Orientation 2: sidestep NE, SW
          ],
        },
        '5L': {
          orientations: [
            [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: -1, r: 0 }, { q: 2, r: 0 }, { q: -2, r: 0 }],
            [{ q: 0, r: 0 }, { q: 0, r: 1 }, { q: 0, r: -1 }, { q: 0, r: 2 }, { q: 0, r: -2 }],
            [{ q: 0, r: 0 }, { q: 1, r: -1 }, { q: -1, r: 1 }, { q: 2, r: -2 }, { q: -2, r: 2 }],
          ],
          perpendicularDirs: [
            [1, 2, 4, 5],
            [0, 1, 3, 4],
            [0, 2, 3, 5],
          ],
          parallelDirs: [
            [0, 3],
            [2, 5],
            [1, 4],
          ],
        },
      },
      unitSizes: [1, 3, 7, '3L', '5L'],
      unitLabels: { 1: '1⬡', 3: '3△', 7: '7⬢', '3L': '3━', '5L': '5━' },
      heuristics: ['hex', 'euclidean'],
      defaultHeuristic: 'hex',
    },
    square4: {
      directions: [
        { q: 0, r: -1 }, { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 0 },
      ],
      formations: {
        1: [{ q: 0, r: 0 }],
        4: [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: 0, r: 1 }, { q: 1, r: 1 }],
        9: [
          { q: -1, r: -1 }, { q: 0, r: -1 }, { q: 1, r: -1 },
          { q: -1, r: 0 }, { q: 0, r: 0 }, { q: 1, r: 0 },
          { q: -1, r: 1 }, { q: 0, r: 1 }, { q: 1, r: 1 }
        ],
      },
      oblongFormations: {
        '3L': {
          orientations: [
            // Orientation 0: horizontal (along q-axis)
            [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: -1, r: 0 }],
            // Orientation 1: vertical (along r-axis)
            [{ q: 0, r: 0 }, { q: 0, r: 1 }, { q: 0, r: -1 }],
          ],
          perpendicularDirs: [
            [0, 2], // Horizontal line: N, S are perpendicular
            [1, 3], // Vertical line: E, W are perpendicular
          ],
          parallelDirs: [
            [1, 3], // Horizontal: E, W
            [0, 2], // Vertical: N, S
          ],
        },
        '5L': {
          orientations: [
            [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: -1, r: 0 }, { q: 2, r: 0 }, { q: -2, r: 0 }],
            [{ q: 0, r: 0 }, { q: 0, r: 1 }, { q: 0, r: -1 }, { q: 0, r: 2 }, { q: 0, r: -2 }],
          ],
          perpendicularDirs: [
            [0, 2],
            [1, 3],
          ],
          parallelDirs: [
            [1, 3],
            [0, 2],
          ],
        },
      },
      unitSizes: [1, 4, 9, '3L', '5L'],
      unitLabels: { 1: '1□', 4: '2×2', 9: '3×3', '3L': '3━', '5L': '5━' },
      heuristics: ['manhattan', 'euclidean'],
      defaultHeuristic: 'manhattan',
    },
    square8: {
      directions: [
        { q: 0, r: -1 }, { q: 1, r: -1 }, { q: 1, r: 0 }, { q: 1, r: 1 },
        { q: 0, r: 1 }, { q: -1, r: 1 }, { q: -1, r: 0 }, { q: -1, r: -1 },
      ],
      formations: {
        1: [{ q: 0, r: 0 }],
        4: [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: 0, r: 1 }, { q: 1, r: 1 }],
        9: [
          { q: -1, r: -1 }, { q: 0, r: -1 }, { q: 1, r: -1 },
          { q: -1, r: 0 }, { q: 0, r: 0 }, { q: 1, r: 0 },
          { q: -1, r: 1 }, { q: 0, r: 1 }, { q: 1, r: 1 }
        ],
      },
      oblongFormations: {
        '3L': {
          orientations: [
            // Orientation 0: horizontal
            [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: -1, r: 0 }],
            // Orientation 1: vertical
            [{ q: 0, r: 0 }, { q: 0, r: 1 }, { q: 0, r: -1 }],
            // Orientation 2: diagonal NE-SW
            [{ q: 0, r: 0 }, { q: 1, r: -1 }, { q: -1, r: 1 }],
            // Orientation 3: diagonal NW-SE
            [{ q: 0, r: 0 }, { q: -1, r: -1 }, { q: 1, r: 1 }],
          ],
          perpendicularDirs: [
            [0, 1, 4, 5, 7], // Horizontal: N, NE, S, SW, NW (not E, SE, W)
            [1, 2, 3, 6, 7], // Vertical: NE, E, SE, W, NW (not N, S)
            [0, 2, 4, 6],     // Diag NE-SW: N, E, S, W
            [0, 2, 4, 6],     // Diag NW-SE: N, E, S, W
          ],
          parallelDirs: [
            [2, 6],    // Horizontal: E, W
            [0, 4],    // Vertical: N, S
            [1, 5],    // Diag NE-SW: NE, SW
            [3, 7],    // Diag NW-SE: SE, NW
          ],
        },
        '5L': {
          orientations: [
            [{ q: 0, r: 0 }, { q: 1, r: 0 }, { q: -1, r: 0 }, { q: 2, r: 0 }, { q: -2, r: 0 }],
            [{ q: 0, r: 0 }, { q: 0, r: 1 }, { q: 0, r: -1 }, { q: 0, r: 2 }, { q: 0, r: -2 }],
            [{ q: 0, r: 0 }, { q: 1, r: -1 }, { q: -1, r: 1 }, { q: 2, r: -2 }, { q: -2, r: 2 }],
            [{ q: 0, r: 0 }, { q: -1, r: -1 }, { q: 1, r: 1 }, { q: -2, r: -2 }, { q: 2, r: 2 }],
          ],
          perpendicularDirs: [
            [0, 1, 4, 5, 7],
            [1, 2, 3, 6, 7],
            [0, 2, 4, 6],
            [0, 2, 4, 6],
          ],
          parallelDirs: [
            [2, 6],
            [0, 4],
            [1, 5],
            [3, 7],
          ],
        },
      },
      unitSizes: [1, 4, 9, '3L', '5L'],
      unitLabels: { 1: '1□', 4: '2×2', 9: '3×3', '3L': '3━', '5L': '5━' },
      heuristics: ['chebyshev', 'euclidean', 'manhattan'],
      defaultHeuristic: 'chebyshev',
    },
  },

  getConfig: (gridType) => GridUtils.CONFIGS[gridType] || GridUtils.CONFIGS.hex,
  getDirections: (gridType) => GridUtils.getConfig(gridType).directions,
  getFormationOffsets: (gridType, size) => {
    const config = GridUtils.getConfig(gridType);
    return config.formations[size] || config.formations[1];
  },
  getFormationCells: (gridType, centerQ, centerR, size, orientation = 0) => {
    if (GridUtils.isOblongUnit(size)) {
      return GridUtils.getOblongCells(gridType, centerQ, centerR, size, orientation);
    }
    const offsets = GridUtils.getFormationOffsets(gridType, size);
    return offsets.map(offset => ({ q: centerQ + offset.q, r: centerR + offset.r }));
  },
  canFormationFit: (grid, gridType, centerQ, centerR, size, ignoreKeys = new Set()) => {
    // For oblong units, check if any orientation fits
    if (GridUtils.isOblongUnit(size)) {
      const numOrients = GridUtils.getNumOrientations(gridType, size);
      for (let o = 0; o < numOrients; o++) {
        if (GridUtils.canOblongFit(grid, gridType, centerQ, centerR, size, o)) return true;
      }
      return false;
    }
    const cells = GridUtils.getFormationCells(gridType, centerQ, centerR, size);
    for (const cell of cells) {
      const key = GridUtils.cellKey(cell.q, cell.r);
      if (ignoreKeys.has(key)) continue;
      const node = grid.get(key);
      if (!node || node.isWall) return false;
    }
    return true;
  },
  getFormationClearance: (grid, gridType, centerQ, centerR, size) => {
    if (size === 1) return 0;
    const cells = GridUtils.getFormationCells(gridType, centerQ, centerR, size);
    let blockedNeighbors = 0;
    for (const cell of cells) {
      const neighbors = GridUtils.getNeighbors(gridType, cell.q, cell.r);
      for (const n of neighbors) {
        const key = GridUtils.cellKey(n.q, n.r);
        const node = grid.get(key);
        if (!node || node.isWall) blockedNeighbors++;
      }
    }
    return blockedNeighbors * 0.1;
  },
  getScaledSnakePenalty: (basePenalty, unitSize) => basePenalty * Math.sqrt(typeof unitSize === 'string' ? parseInt(unitSize) : unitSize),
  
  // Oblong formation helpers
  isOblongUnit: (unitSize) => typeof unitSize === 'string' && unitSize.endsWith('L'),
  getOblongSize: (unitSize) => typeof unitSize === 'string' ? parseInt(unitSize) : unitSize,
  getEffectiveSize: (unitSize) => typeof unitSize === 'string' ? parseInt(unitSize) : unitSize,
  isMultiUnit: (unitSize) => unitSize !== 1 && unitSize !== '1',
  getOblongFormation: (gridType, unitSize) => {
    const config = GridUtils.CONFIGS[gridType];
    return config?.oblongFormations?.[unitSize] || null;
  },
  getOblongCells: (gridType, centerQ, centerR, unitSize, orientation) => {
    const oblong = GridUtils.getOblongFormation(gridType, unitSize);
    if (!oblong) return [{ q: centerQ, r: centerR }];
    const cells = oblong.orientations[orientation] || oblong.orientations[0];
    return cells.map(c => ({ q: centerQ + c.q, r: centerR + c.r }));
  },
  canOblongFit: (grid, gridType, centerQ, centerR, unitSize, orientation) => {
    const cells = GridUtils.getOblongCells(gridType, centerQ, centerR, unitSize, orientation);
    for (const cell of cells) {
      const key = GridUtils.cellKey(cell.q, cell.r);
      const node = grid.get(key);
      if (!node || node.isWall) return false;
    }
    return true;
  },
  getNumOrientations: (gridType, unitSize) => {
    const oblong = GridUtils.getOblongFormation(gridType, unitSize);
    return oblong ? oblong.orientations.length : 1;
  },
  // Calculate formation width perpendicular to a given travel direction
  getFormationWidthForDirection: (gridType, unitSize, orientation, travelAngle, cellSize) => {
    if (unitSize === 1) return cellSize * 0.8;
    
    // Get formation cells
    const cells = GridUtils.getFormationCells(gridType, 0, 0, unitSize, orientation);
    if (cells.length <= 1) return cellSize * 0.8;
    
    // Convert cells to pixel positions
    const pixelCells = cells.map(c => GridUtils.cellToPixel(gridType, c.q, c.r, cellSize));
    
    // Calculate the maximum extent of the formation (bounding box)
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const p of pixelCells) {
      minX = Math.min(minX, p.x);
      maxX = Math.max(maxX, p.x);
      minY = Math.min(minY, p.y);
      maxY = Math.max(maxY, p.y);
    }
    
    // Return formation extent (this is center-to-center, add some for cell radius)
    const extentX = maxX - minX;
    const extentY = maxY - minY;
    return Math.max(extentX, extentY) + cellSize * 0.5;
  },
  isPerpendicularMove: (gridType, unitSize, orientation, dirIndex) => {
    const oblong = GridUtils.getOblongFormation(gridType, unitSize);
    if (!oblong) return true;
    return oblong.perpendicularDirs[orientation]?.includes(dirIndex) ?? true;
  },
  getRotationCost: (fromOrient, toOrient, numOrientations) => {
    if (fromOrient === toOrient) return 0;
    // Calculate minimum rotation steps (can rotate either direction)
    const diff = Math.abs(fromOrient - toOrient);
    const steps = Math.min(diff, numOrientations - diff);
    return steps * 0.5; // 0.5 cost per 60° rotation (hex) or 90° (square4) or 45° (square8)
  },
  findBestOrientationForMove: (grid, gridType, fromQ, fromR, toQ, toR, unitSize, currentOrientation, canSnake, snakePenalty = 1.5) => {
    const oblong = GridUtils.getOblongFormation(gridType, unitSize);
    if (!oblong) return { orientation: 0, canFit: true, cost: 0, isSnaking: false };
    
    const numOrients = oblong.orientations.length;
    const dirs = GridUtils.getDirections(gridType);
    const dq = toQ - fromQ, dr = toR - fromR;
    const dirIndex = dirs.findIndex(d => d.q === dq && d.r === dr);
    const effectiveSize = GridUtils.getEffectiveSize(unitSize);
    const scaledSnakePenalty = GridUtils.getScaledSnakePenalty(snakePenalty, effectiveSize);
    
    let bestResult = null;
    
    // Try all orientations, prefer ones where move is perpendicular (in formation)
    for (let orient = 0; orient < numOrients; orient++) {
      const canFit = GridUtils.canOblongFit(grid, gridType, toQ, toR, unitSize, orient);
      const isPerpendicular = GridUtils.isPerpendicularMove(gridType, unitSize, orient, dirIndex);
      
      // Parallel movement (not perpendicular) OR not fitting = snaking, requires canSnake
      const needsSnake = !isPerpendicular || !canFit;
      if (needsSnake && !canSnake) continue;
      
      const rotCost = GridUtils.getRotationCost(currentOrientation, orient, numOrients);
      // Snaking (parallel move or doesn't fit) uses snake penalty
      const snakeCost = needsSnake ? scaledSnakePenalty : 0;
      const totalCost = rotCost + snakeCost;
      
      if (!bestResult || totalCost < bestResult.cost) {
        bestResult = { orientation: orient, canFit, cost: totalCost, isSnaking: needsSnake, isPerpendicular };
      }
    }
    
    return bestResult || { orientation: currentOrientation, canFit: false, cost: 999, isSnaking: true };
  },
  cellKey: (q, r) => `${q},${r}`,
  parseKey: (key) => { const [q, r] = key.split(',').map(Number); return { q, r }; },
  getNeighbors: (gridType, q, r) => {
    const dirs = GridUtils.getDirections(gridType);
    return dirs.map(d => ({ q: q + d.q, r: r + d.r }));
  },
  axialToCube: (q, r) => ({ x: q, y: -q - r, z: r }),
  cubeDistance: (a, b) => Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z)),
  hexDistance: (q1, r1, q2, r2) => {
    const a = GridUtils.axialToCube(q1, r1);
    const b = GridUtils.axialToCube(q2, r2);
    return GridUtils.cubeDistance(a, b);
  },
  hexToPixel: (q, r, size) => ({
    x: size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r),
    y: size * (3 / 2 * r)
  }),
  axialRound: (q, r) => {
    const cube = GridUtils.axialToCube(q, r);
    let rx = Math.round(cube.x), ry = Math.round(cube.y), rz = Math.round(cube.z);
    const xDiff = Math.abs(rx - cube.x), yDiff = Math.abs(ry - cube.y), zDiff = Math.abs(rz - cube.z);
    if (xDiff > yDiff && xDiff > zDiff) rx = -ry - rz;
    else if (yDiff > zDiff) ry = -rx - rz;
    else rz = -rx - ry;
    return { q: rx, r: rz };
  },
  hexCorners: (cx, cy, size) => {
    const corners = [];
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 180 * (60 * i - 30);
      corners.push({ x: cx + size * Math.cos(angle), y: cy + size * Math.sin(angle) });
    }
    return corners;
  },
  squareToPixel: (q, r, size) => ({ x: q * size * 2, y: r * size * 2 }),
  cellToPixel: (gridType, q, r, size) => gridType === 'hex' ? GridUtils.hexToPixel(q, r, size) : GridUtils.squareToPixel(q, r, size),
  manhattanDistance: (q1, r1, q2, r2) => Math.abs(q1 - q2) + Math.abs(r1 - r2),
  chebyshevDistance: (q1, r1, q2, r2) => Math.max(Math.abs(q1 - q2), Math.abs(r1 - r2)),
  euclideanDistance: (q1, r1, q2, r2) => Math.sqrt((q1 - q2) ** 2 + (r1 - r2) ** 2),
  getDistance: (gridType, heuristic, q1, r1, q2, r2) => {
    switch (heuristic) {
      case 'hex': return GridUtils.hexDistance(q1, r1, q2, r2);
      case 'manhattan': return GridUtils.manhattanDistance(q1, r1, q2, r2);
      case 'chebyshev': return GridUtils.chebyshevDistance(q1, r1, q2, r2);
      case 'euclidean': return GridUtils.euclideanDistance(q1, r1, q2, r2);
      default:
        if (gridType === 'hex') return GridUtils.hexDistance(q1, r1, q2, r2);
        if (gridType === 'square4') return GridUtils.manhattanDistance(q1, r1, q2, r2);
        return GridUtils.chebyshevDistance(q1, r1, q2, r2);
    }
  },
  getMovementCost: (gridType, dq, dr, baseWeight) => {
    if (gridType === 'hex') return baseWeight;
    if (gridType === 'square8' && dq !== 0 && dr !== 0) return baseWeight * 1.414;
    return baseWeight;
  },
  // Line of Sight functions
  hexLerp: (a, b, t) => ({ q: a.q + (b.q - a.q) * t, r: a.r + (b.r - a.r) * t }),
  hexRound: (q, r) => {
    // Convert to cube, round, convert back
    const s = -q - r;
    let rq = Math.round(q), rr = Math.round(r), rs = Math.round(s);
    const qDiff = Math.abs(rq - q), rDiff = Math.abs(rr - r), sDiff = Math.abs(rs - s);
    if (qDiff > rDiff && qDiff > sDiff) rq = -rr - rs;
    else if (rDiff > sDiff) rr = -rq - rs;
    return { q: rq, r: rr };
  },
  getHexLine: (q1, r1, q2, r2) => {
    const dist = Math.max(Math.abs(q2 - q1), Math.abs(r2 - r1), Math.abs((q1 + r1) - (q2 + r2)));
    if (dist === 0) return [{ q: q1, r: r1 }];
    const cells = [];
    for (let i = 0; i <= dist; i++) {
      const t = i / dist;
      const lerped = GridUtils.hexLerp({ q: q1 + 0.000001, r: r1 + 0.000001 }, { q: q2, r: r2 }, t);
      cells.push(GridUtils.hexRound(lerped.q, lerped.r));
    }
    return cells;
  },
  hasLineOfSight: (grid, gridType, q1, r1, q2, r2) => {
    if (gridType !== 'hex') {
      // Square grid: use Bresenham
      const cells = [];
      let x0 = q1, y0 = r1, x1 = q2, y1 = r2;
      const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
      const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;
      while (true) {
        cells.push({ q: x0, r: y0 });
        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x0 += sx; }
        if (e2 < dx) { err += dx; y0 += sy; }
      }
      return cells.every(c => { const node = grid.get(GridUtils.cellKey(c.q, c.r)); return node && !node.isWall; });
    }
    const line = GridUtils.getHexLine(q1, r1, q2, r2);
    return line.every(c => { const node = grid.get(GridUtils.cellKey(c.q, c.r)); return node && !node.isWall; });
  },
  // Formation LOS: check all cells in formation have clear LOS
  formationHasLOS: (grid, gridType, fromQ, fromR, toQ, toR, unitSize, fromOrient = 0, toOrient = 0) => {
    if (unitSize === 1) return GridUtils.hasLineOfSight(grid, gridType, fromQ, fromR, toQ, toR);
    
    const fromCells = GridUtils.getFormationCells(gridType, fromQ, fromR, unitSize, fromOrient);
    const toCells = GridUtils.getFormationCells(gridType, toQ, toR, unitSize, toOrient);
    
    if (fromCells.length !== toCells.length) return false;
    
    // Check LOS for each corresponding cell pair
    for (let i = 0; i < fromCells.length; i++) {
      if (!GridUtils.hasLineOfSight(grid, gridType, fromCells[i].q, fromCells[i].r, toCells[i].q, toCells[i].r)) {
        return false;
      }
    }
    
    // For rotating formations, also check intermediate orientations
    if (GridUtils.isOblongUnit(unitSize) && fromOrient !== toOrient) {
      const numOrients = GridUtils.getNumOrientations(gridType, unitSize);
      const dist = Math.max(Math.abs(toQ - fromQ), Math.abs(toR - fromR), Math.abs((fromQ + fromR) - (toQ + toR)));
      const orientDiff = ((toOrient - fromOrient) % numOrients + numOrients) % numOrients;
      const orientStep = orientDiff <= numOrients / 2 ? 1 : -1;
      
      // Sample along the path
      const samples = Math.max(dist, Math.abs(toOrient - fromOrient) * 2);
      for (let i = 1; i < samples; i++) {
        const t = i / samples;
        const midQ = Math.round(fromQ + (toQ - fromQ) * t);
        const midR = Math.round(fromR + (toR - fromR) * t);
        // Interpolate orientation (step-wise, not continuous)
        const orientProgress = Math.floor(t * Math.abs(toOrient - fromOrient));
        const midOrient = (fromOrient + orientStep * orientProgress + numOrients) % numOrients;
        
        // Check formation fits at this intermediate point
        if (!GridUtils.canOblongFit(grid, gridType, midQ, midR, unitSize, midOrient)) {
          return false;
        }
      }
    }
    
    return true;
  },
  // Find waypoints (direction changes) in a path - for marker display only
  extractPathWaypoints: (path) => {
    if (!path || path.length <= 2) return path ? [...path] : [];
    if (!path[0]?.key) return [...path];
    
    const waypoints = [path[0]]; // Always include start
    
    for (let i = 1; i < path.length - 1; i++) {
      const prev = path[i - 1];
      const curr = path[i];
      const next = path[i + 1];
      
      if (!prev?.key || !curr?.key || !next?.key) continue;
      
      const prevPos = GridUtils.parseKey(prev.key);
      const currPos = GridUtils.parseKey(curr.key);
      const nextPos = GridUtils.parseKey(next.key);
      
      // Check if direction changed
      const d1q = currPos.q - prevPos.q, d1r = currPos.r - prevPos.r;
      const d2q = nextPos.q - currPos.q, d2r = nextPos.r - currPos.r;
      const directionChanged = d1q !== d2q || d1r !== d2r;
      
      // Check if compactness changed (snake transition)
      const compactnessChanged = (prev.isCompact !== false) !== (curr.isCompact !== false);
      
      if (directionChanged || compactnessChanged) {
        waypoints.push(curr);
      }
    }
    
    waypoints.push(path[path.length - 1]); // Always include end
    return waypoints;
  },
  // LOS-based waypoint reduction - drops unnecessary waypoints where straight lines work
  // This is actual post-processing that modifies the path, keeping only essential waypoints
  reducePathByLOS: (path, grid, gridType) => {
    if (!path || path.length <= 2) return path ? [...path] : [];
    if (!path[0]?.key) return [...path];
    
    const reduced = [path[0]]; // Always include start
    let anchor = 0; // Current anchor point we're checking LOS from
    
    for (let i = 2; i < path.length; i++) {
      const anchorPos = GridUtils.parseKey(path[anchor].key);
      const currentPos = GridUtils.parseKey(path[i].key);
      const prevPos = GridUtils.parseKey(path[i - 1].key);
      
      // Check if we have LOS from anchor to current position
      const hasLOS = GridUtils.hasLineOfSight(grid, gridType, anchorPos.q, anchorPos.r, currentPos.q, currentPos.r);
      
      // Check if compactness changes (snake transitions must be preserved)
      const prevCompact = path[i - 1].isCompact !== false;
      const currCompact = path[i].isCompact !== false;
      const compactnessChanging = prevCompact !== currCompact;
      
      // If LOS blocked or compactness changing, keep the waypoint
      if (!hasLOS || compactnessChanging) {
        const lastAdded = reduced[reduced.length - 1];
        if (path[i - 1].key !== lastAdded.key) {
          reduced.push(path[i - 1]);
        }
        anchor = i - 1;
      }
    }
    
    // Always include end
    const lastAdded = reduced[reduced.length - 1];
    if (path[path.length - 1].key !== lastAdded.key) {
      reduced.push(path[path.length - 1]);
    }
    
    return reduced;
  },
  // Helper for square grid line drawing
  getSquareLine: (q1, r1, q2, r2) => {
    const cells = [];
    let x0 = q1, y0 = r1, x1 = q2, y1 = r2;
    const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    while (true) {
      cells.push({ q: x0, r: y0 });
      if (x0 === x1 && y0 === y1) break;
      const e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x0 += sx; }
      if (e2 < dx) { err += dx; y0 += sy; }
    }
    return cells;
  },
};

class MinHeap {
  constructor() { this.heap = []; }
  push(item, priority) { this.heap.push({ item, priority }); this.bubbleUp(this.heap.length - 1); }
  pop() {
    if (this.heap.length === 0) return null;
    const min = this.heap[0];
    const end = this.heap.pop();
    if (this.heap.length > 0) { this.heap[0] = end; this.bubbleDown(0); }
    return min.item;
  }
  isEmpty() { return this.heap.length === 0; }
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (this.heap[parentIndex].priority <= this.heap[index].priority) break;
      [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
      index = parentIndex;
    }
  }
  bubbleDown(index) {
    const length = this.heap.length;
    while (true) {
      const leftChild = 2 * index + 1, rightChild = 2 * index + 2;
      let smallest = index;
      if (leftChild < length && this.heap[leftChild].priority < this.heap[smallest].priority) smallest = leftChild;
      if (rightChild < length && this.heap[rightChild].priority < this.heap[smallest].priority) smallest = rightChild;
      if (smallest === index) break;
      [this.heap[smallest], this.heap[index]] = [this.heap[index], this.heap[smallest]];
      index = smallest;
    }
  }
}

const Algorithms = {
  aStar: (grid, start, end, heuristicWeight = 1, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5, initialOrientation = null) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScore = new Map(), fScore = new Map(), previous = new Map(), visited = [], formationState = new Map();
    const orientationState = new Map(); // Track orientation for oblong units
    const isOblong = GridUtils.isOblongUnit(unitSize);
    const numOrientations = isOblong ? GridUtils.getNumOrientations(gridType, unitSize) : 1;
    
    // For oblong units, use provided orientation or find best starting orientation
    let startOrientation = initialOrientation ?? 0;
    let startFits = true;
    if (isOblong) {
      if (initialOrientation === null) {
        // Auto-calculate best orientation perpendicular to goal direction
        const oblong = GridUtils.getOblongFormation(gridType, unitSize);
        const dirs = GridUtils.getDirections(gridType);
        const dq = end.q - start.q, dr = end.r - start.r;
        let bestDirIdx = 0, bestDot = -Infinity;
        dirs.forEach((d, i) => {
          const dot = d.q * dq + d.r * dr;
          if (dot > bestDot) { bestDot = dot; bestDirIdx = i; }
        });
        let bestOrient = 0;
        for (let o = 0; o < numOrientations; o++) {
          if (GridUtils.canOblongFit(grid, gridType, start.q, start.r, unitSize, o)) {
            if (oblong.perpendicularDirs[o].includes(bestDirIdx)) { bestOrient = o; break; }
            if (bestOrient === 0) bestOrient = o;
          }
        }
        startOrientation = bestOrient;
      }
      startFits = GridUtils.canOblongFit(grid, gridType, start.q, start.r, unitSize, startOrientation);
    } else if (unitSize !== 1) {
      startFits = GridUtils.canFormationFit(grid, gridType, start.q, start.r, unitSize);
    }
    if (!startFits && !canSnake) return { previous, visited, endKey: null, gScore, fScore, formationState, orientationState };
    
    gScore.set(startKey, 0);
    fScore.set(startKey, heuristicWeight * GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    formationState.set(startKey, startFits);
    orientationState.set(startKey, startOrientation);
    openSet.push(startKey, fScore.get(startKey));
    const inOpenSet = new Set([startKey]);
    
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      if (currentKey === endKey) return { previous, visited, endKey, gScore, fScore, formationState, orientationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentNode = grid.get(currentKey);
      if (!currentNode) continue;
      const currentIsCompact = formationState.get(currentKey) ?? true;
      const currentOrientation = orientationState.get(currentKey) ?? 0;
      
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        
        let canFitCompact, neighborOrientation, rotationCost = 0, parallelPenalty = 0;
        
        if (isOblong) {
          // Find best orientation for this move
          const moveResult = GridUtils.findBestOrientationForMove(
            grid, gridType, current.q, current.r, neighbor.q, neighbor.r, 
            unitSize, currentOrientation, canSnake, snakePenalty
          );
          if (moveResult.cost >= 999) continue; // No valid move found
          canFitCompact = !moveResult.isSnaking; // Snaking = not compact
          neighborOrientation = moveResult.orientation;
          rotationCost = moveResult.cost;
        } else {
          canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
          if (!canFitCompact && !canSnake) continue;
          neighborOrientation = 0;
        }
        
        const dq = neighbor.q - current.q, dr = neighbor.r - current.r;
        let moveCost = GridUtils.getMovementCost(gridType, dq, dr, 1) + rotationCost;
        let neighborIsCompact = canFitCompact;
        
        const effectiveUnitSize = isOblong ? GridUtils.getOblongSize(unitSize) : unitSize;
        // For non-oblong multi-unit, handle snake costs here
        if (effectiveUnitSize > 1 && !isOblong) {
          if (canFitCompact) {
            if (!isOblong) moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize);
            if (!currentIsCompact) moveCost += snakePenalty * 0.3; // Reforming bonus
          } else if (canSnake) {
            neighborIsCompact = false;
            moveCost += GridUtils.getScaledSnakePenalty(snakePenalty, effectiveUnitSize) * (currentIsCompact ? 1 : 0.15);
          }
        }
        
        const tentativeG = gScore.get(currentKey) + moveCost;
        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
          previous.set(neighborKey, currentKey);
          gScore.set(neighborKey, tentativeG);
          formationState.set(neighborKey, neighborIsCompact);
          orientationState.set(neighborKey, neighborOrientation);
          const f = tentativeG + heuristicWeight * GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r);
          fScore.set(neighborKey, f);
          if (!inOpenSet.has(neighborKey)) { openSet.push(neighborKey, f); inOpenSet.add(neighborKey); }
        }
      }
    }
    return { previous, visited, endKey: null, gScore, fScore, formationState, orientationState };
  },
  dijkstra: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false, snakePenalty = 1.5, initialOrientation = null) => Algorithms.aStar(grid, start, end, 0, gridType, 'default', unitSize, canSnake, snakePenalty, initialOrientation),
  greedyBestFirst: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const previous = new Map(), visited = [], gScore = new Map(), formationState = new Map();
    
    // Check if formation fits at start
    const startFits = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, start.q, start.r, unitSize);
    if (!startFits && !canSnake) return { previous, visited, endKey: null, gScore, formationState };
    
    openSet.push(startKey, GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    gScore.set(startKey, 0);
    formationState.set(startKey, startFits);
    const inOpenSet = new Set([startKey]);
    
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        
        // Skip if center cell doesn't exist or is a wall
        if (!neighborNode || neighborNode.isWall) continue;
        // Skip if already visited
        if (previous.has(neighborKey) || neighborKey === startKey) continue;
        
        // Check if formation fits at this position
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        
        // Skip if formation doesn't fit and snaking is disabled
        if (!canFitCompact && !canSnake) continue;
        
        previous.set(neighborKey, currentKey);
        formationState.set(neighborKey, canFitCompact);
        
        let moveCost = 1;
        if (GridUtils.isMultiUnit(unitSize)) {
          if (canFitCompact) {
            moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize);
          } else if (canSnake) {
            moveCost += GridUtils.getScaledSnakePenalty(snakePenalty, unitSize) * (currentIsCompact ? 1 : 0.15);
          }
        }
        gScore.set(neighborKey, (gScore.get(currentKey) || 0) + moveCost);
        openSet.push(neighborKey, GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r));
        inOpenSet.add(neighborKey);
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  bfs: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false) => {
    const queue = [];
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const previous = new Map(), visited = [], gScore = new Map(), formationState = new Map();
    queue.push(startKey);
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    const inQueue = new Set([startKey]);
    while (queue.length > 0) {
      const currentKey = queue.shift();
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      visited.push(currentKey);
      for (const neighbor of GridUtils.getNeighbors(gridType, GridUtils.parseKey(currentKey).q, GridUtils.parseKey(currentKey).r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        if (inQueue.has(neighborKey)) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        previous.set(neighborKey, currentKey);
        formationState.set(neighborKey, canFitCompact);
        gScore.set(neighborKey, (gScore.get(currentKey) || 0) + 1);
        queue.push(neighborKey);
        inQueue.add(neighborKey);
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  dfs: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false) => {
    const stack = [];
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const previous = new Map(), visited = [], gScore = new Map(), formationState = new Map();
    stack.push(startKey);
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    const inStack = new Set([startKey]);
    while (stack.length > 0) {
      const currentKey = stack.pop();
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      visited.push(currentKey);
      for (const neighbor of GridUtils.getNeighbors(gridType, GridUtils.parseKey(currentKey).q, GridUtils.parseKey(currentKey).r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        if (inStack.has(neighborKey)) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        previous.set(neighborKey, currentKey);
        formationState.set(neighborKey, canFitCompact);
        gScore.set(neighborKey, (gScore.get(currentKey) || 0) + 1);
        stack.push(neighborKey);
        inStack.add(neighborKey);
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  swarm: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScore = new Map(), previous = new Map(), visited = [], formationState = new Map();
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    openSet.push(startKey, GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    const inOpenSet = new Set([startKey]);
    let iteration = 0;
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      iteration++;
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        let moveCost = 1, neighborIsCompact = canFitCompact;
        if (GridUtils.isMultiUnit(unitSize)) {
          if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
          else if (canSnake) { neighborIsCompact = false; moveCost += GridUtils.getScaledSnakePenalty(snakePenalty, unitSize) * (currentIsCompact ? 1 : 0.15); }
        }
        const tentativeG = gScore.get(currentKey) + moveCost;
        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
          previous.set(neighborKey, currentKey);
          gScore.set(neighborKey, tentativeG);
          formationState.set(neighborKey, neighborIsCompact);
          const h = GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r);
          if (!inOpenSet.has(neighborKey)) { openSet.push(neighborKey, tentativeG + (1 + (h / (iteration + 1)) * 2) * h); inOpenSet.add(neighborKey); }
        }
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  convergentSwarm: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSet = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScore = new Map(), previous = new Map(), visited = [], formationState = new Map();
    gScore.set(startKey, 0);
    formationState.set(startKey, true);
    const maxH = GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r);
    openSet.push(startKey, maxH);
    const inOpenSet = new Set([startKey]);
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      inOpenSet.delete(currentKey);
      if (currentKey === endKey) return { previous, visited, endKey, gScore, formationState };
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
        if (!canFitCompact && !canSnake) continue;
        let moveCost = 1, neighborIsCompact = canFitCompact;
        if (GridUtils.isMultiUnit(unitSize)) {
          if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
          else if (canSnake) { neighborIsCompact = false; moveCost += GridUtils.getScaledSnakePenalty(snakePenalty, unitSize) * (currentIsCompact ? 1 : 0.15); }
        }
        const tentativeG = gScore.get(currentKey) + moveCost;
        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
          previous.set(neighborKey, currentKey);
          gScore.set(neighborKey, tentativeG);
          formationState.set(neighborKey, neighborIsCompact);
          const h = GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r);
          const progress = 1 - (h / maxH);
          if (!inOpenSet.has(neighborKey)) { openSet.push(neighborKey, tentativeG + (1 + (1 - progress) * 3) * h); inOpenSet.add(neighborKey); }
        }
      }
    }
    return { previous, visited, endKey: null, gScore, formationState };
  },
  bidirectionalSwarm: (grid, start, end, gridType = 'hex', heuristic = 'default', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const openSetStart = new MinHeap(), openSetEnd = new MinHeap();
    const startKey = GridUtils.cellKey(start.q, start.r), endKey = GridUtils.cellKey(end.q, end.r);
    const gScoreStart = new Map(), gScoreEnd = new Map();
    const previousStart = new Map(), previousEnd = new Map();
    const visitedStart = new Set(), visitedEnd = new Set();
    const visited = [], formationStateStart = new Map(), formationStateEnd = new Map();
    gScoreStart.set(startKey, 0); gScoreEnd.set(endKey, 0);
    formationStateStart.set(startKey, true); formationStateEnd.set(endKey, true);
    openSetStart.push(startKey, GridUtils.getDistance(gridType, heuristic, start.q, start.r, end.q, end.r));
    openSetEnd.push(endKey, GridUtils.getDistance(gridType, heuristic, end.q, end.r, start.q, start.r));
    const inOpenStart = new Set([startKey]), inOpenEnd = new Set([endKey]);
    let meetingPoint = null;
    while (!openSetStart.isEmpty() && !openSetEnd.isEmpty()) {
      if (!openSetStart.isEmpty()) {
        const currentKey = openSetStart.pop(); inOpenStart.delete(currentKey); visitedStart.add(currentKey); visited.push(currentKey);
        if (visitedEnd.has(currentKey)) { meetingPoint = currentKey; break; }
        const current = GridUtils.parseKey(currentKey);
        const currentIsCompact = formationStateStart.get(currentKey) ?? true;
        for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
          const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
          const neighborNode = grid.get(neighborKey);
          if (!neighborNode || neighborNode.isWall || visitedStart.has(neighborKey)) continue;
          const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
          if (!canFitCompact && !canSnake) continue;
          let moveCost = 1, neighborIsCompact = canFitCompact;
          if (GridUtils.isMultiUnit(unitSize)) {
            if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
            else if (canSnake) { neighborIsCompact = false; moveCost += GridUtils.getScaledSnakePenalty(snakePenalty, unitSize) * (currentIsCompact ? 1 : 0.15); }
          }
          const tentativeG = gScoreStart.get(currentKey) + moveCost;
          if (!gScoreStart.has(neighborKey) || tentativeG < gScoreStart.get(neighborKey)) {
            previousStart.set(neighborKey, currentKey); gScoreStart.set(neighborKey, tentativeG); formationStateStart.set(neighborKey, neighborIsCompact);
            if (!inOpenStart.has(neighborKey)) { openSetStart.push(neighborKey, tentativeG + GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, end.q, end.r)); inOpenStart.add(neighborKey); }
          }
        }
      }
      if (!openSetEnd.isEmpty()) {
        const currentKey = openSetEnd.pop(); inOpenEnd.delete(currentKey); visitedEnd.add(currentKey); visited.push(currentKey);
        if (visitedStart.has(currentKey)) { meetingPoint = currentKey; break; }
        const current = GridUtils.parseKey(currentKey);
        const currentIsCompact = formationStateEnd.get(currentKey) ?? true;
        for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
          const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
          const neighborNode = grid.get(neighborKey);
          if (!neighborNode || neighborNode.isWall || visitedEnd.has(neighborKey)) continue;
          const canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
          if (!canFitCompact && !canSnake) continue;
          let moveCost = 1, neighborIsCompact = canFitCompact;
          if (GridUtils.isMultiUnit(unitSize)) {
            if (canFitCompact) { moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize); if (!currentIsCompact) moveCost += snakePenalty * 0.3; }
            else if (canSnake) { neighborIsCompact = false; moveCost += GridUtils.getScaledSnakePenalty(snakePenalty, unitSize) * (currentIsCompact ? 1 : 0.15); }
          }
          const tentativeG = gScoreEnd.get(currentKey) + moveCost;
          if (!gScoreEnd.has(neighborKey) || tentativeG < gScoreEnd.get(neighborKey)) {
            previousEnd.set(neighborKey, currentKey); gScoreEnd.set(neighborKey, tentativeG); formationStateEnd.set(neighborKey, neighborIsCompact);
            if (!inOpenEnd.has(neighborKey)) { openSetEnd.push(neighborKey, tentativeG + GridUtils.getDistance(gridType, heuristic, neighbor.q, neighbor.r, start.q, start.r)); inOpenEnd.add(neighborKey); }
          }
        }
      }
    }
    const mergedGScore = new Map(gScoreStart); for (const [k, v] of gScoreEnd) if (!mergedGScore.has(k)) mergedGScore.set(k, v);
    const mergedFormationState = new Map(formationStateStart); for (const [k, v] of formationStateEnd) if (!mergedFormationState.has(k)) mergedFormationState.set(k, v);
    return { previousStart, previousEnd, visitedStart: [...visitedStart], visitedEnd: [...visitedEnd], visited, meetingPoint, gScoreStart, gScoreEnd, gScore: mergedGScore, formationStateStart, formationStateEnd, formationState: mergedFormationState };
  },
  flowField: (grid, start, end, gridType = 'hex', unitSize = 1, canSnake = false, snakePenalty = 1.5) => {
    const endKey = GridUtils.cellKey(end.q, end.r), startKey = GridUtils.cellKey(start.q, start.r);
    const costField = new Map(), flowVectors = new Map(), visited = [], formationState = new Map();
    const orientationState = new Map();
    const isOblong = GridUtils.isOblongUnit(unitSize);
    const numOrientations = isOblong ? GridUtils.getNumOrientations(gridType, unitSize) : 1;
    const effectiveUnitSize = GridUtils.getEffectiveSize(unitSize);
    
    const openSet = new MinHeap();
    costField.set(endKey, 0); 
    formationState.set(endKey, true); 
    orientationState.set(endKey, 0);
    openSet.push(endKey, 0);
    
    // Build cost field from goal outward
    while (!openSet.isEmpty()) {
      const currentKey = openSet.pop();
      const current = GridUtils.parseKey(currentKey);
      visited.push(currentKey);
      const currentCost = costField.get(currentKey);
      const currentIsCompact = formationState.get(currentKey) ?? true;
      const currentOrientation = orientationState.get(currentKey) ?? 0;
      
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborNode = grid.get(neighborKey);
        if (!neighborNode || neighborNode.isWall) continue;
        
        let canFitCompact, neighborOrientation = 0, rotationCost = 0;
        
        if (isOblong) {
          // For flow field (expanding from goal), we check what orientation works at neighbor
          // and cost to rotate from that to current orientation when following the flow
          const oblong = GridUtils.getOblongFormation(gridType, unitSize);
          const dirs = GridUtils.getDirections(gridType);
          // Direction FROM neighbor TO current (the flow direction)
          const dq = current.q - neighbor.q, dr = current.r - neighbor.r;
          const dirIndex = dirs.findIndex(d => d.q === dq && d.r === dr);
          const scaledSnakePenalty = GridUtils.getScaledSnakePenalty(snakePenalty, effectiveUnitSize);
          
          let bestOrient = 0, bestCost = Infinity, bestFits = false, bestIsSnaking = true;
          for (let o = 0; o < numOrientations; o++) {
            const fits = GridUtils.canOblongFit(grid, gridType, neighbor.q, neighbor.r, unitSize, o);
            const isPerpendicular = oblong.perpendicularDirs[o]?.includes(dirIndex) ?? true;
            
            // Parallel movement OR not fitting = snaking
            const needsSnake = !isPerpendicular || !fits;
            if (needsSnake && !canSnake) continue;
            
            const rotCost = GridUtils.getRotationCost(o, currentOrientation, numOrientations);
            const snakeCost = needsSnake ? scaledSnakePenalty : 0;
            const totalCost = rotCost + snakeCost;
            
            if (totalCost < bestCost) {
              bestCost = totalCost;
              bestOrient = o;
              bestFits = fits;
              bestIsSnaking = needsSnake;
            }
          }
          if (bestCost === Infinity) continue;
          canFitCompact = !bestIsSnaking;
          neighborOrientation = bestOrient;
          rotationCost = bestCost;
        } else {
          canFitCompact = unitSize === 1 || GridUtils.canFormationFit(grid, gridType, neighbor.q, neighbor.r, unitSize);
          if (!canFitCompact && !canSnake) continue;
        }
        
        const dq = neighbor.q - current.q, dr = neighbor.r - current.r;
        let moveCost = GridUtils.getMovementCost(gridType, dq, dr, 1) + rotationCost;
        let neighborIsCompact = canFitCompact;
        
        // For non-oblong multi-unit, handle snake costs here (oblong already handled above)
        if (effectiveUnitSize > 1 && !isOblong) {
          if (canFitCompact) {
            moveCost += GridUtils.getFormationClearance(grid, gridType, neighbor.q, neighbor.r, unitSize);
            if (!currentIsCompact) moveCost += snakePenalty * 0.3;
          } else if (canSnake) {
            neighborIsCompact = false;
            moveCost += GridUtils.getScaledSnakePenalty(snakePenalty, effectiveUnitSize) * (currentIsCompact ? 1 : 0.15);
          }
        }
        
        const newCost = currentCost + moveCost;
        if (!costField.has(neighborKey) || newCost < costField.get(neighborKey)) {
          costField.set(neighborKey, newCost);
          formationState.set(neighborKey, neighborIsCompact);
          orientationState.set(neighborKey, neighborOrientation);
          openSet.push(neighborKey, newCost);
        }
      }
    }
    
    // Build flow vectors pointing toward lowest cost neighbor
    for (const [key] of costField) {
      const current = GridUtils.parseKey(key);
      const currentCost = costField.get(key);
      let bestNeighbor = null, bestCost = currentCost;
      for (const neighbor of GridUtils.getNeighbors(gridType, current.q, current.r)) {
        const neighborKey = GridUtils.cellKey(neighbor.q, neighbor.r);
        const neighborCost = costField.get(neighborKey);
        if (neighborCost !== undefined && neighborCost < bestCost) {
          bestCost = neighborCost;
          bestNeighbor = neighbor;
        }
      }
      if (bestNeighbor) flowVectors.set(key, { direction: { q: bestNeighbor.q - current.q, r: bestNeighbor.r - current.r } });
    }
    
    // Trace path from start following flow vectors
    const path = [];
    let current = startKey;
    const pathVisited = new Set();
    while (current && current !== endKey && !pathVisited.has(current)) {
      pathVisited.add(current);
      const flow = flowVectors.get(current);
      if (!flow) break;
      const pos = GridUtils.parseKey(current);
      const nextKey = GridUtils.cellKey(pos.q + flow.direction.q, pos.r + flow.direction.r);
      path.push({ 
        key: nextKey, 
        isCompact: formationState.get(nextKey) ?? true,
        orientation: orientationState.get(nextKey) ?? 0
      });
      current = nextKey;
    }
    
    return { visited, path, costField, flowVectors, gScore: costField, formationState, orientationState };
  },
};

function PathfindingVisualizer() {
  const [gridType, setGridType] = useState('hex');
  const [heuristic, setHeuristic] = useState('default');
  const [grid, setGrid] = useState(new Map());
  const [startNode, setStartNode] = useState({ q: -10, r: 0 });
  const [endNode, setEndNode] = useState({ q: 10, r: 0 });
  const [startOrientation, setStartOrientation] = useState(0);
  const [endOrientation, setEndOrientation] = useState(0);
  const [selectedAlgorithm, setSelectedAlgorithm] = useState('aStar');
  const [isRunning, setIsRunning] = useState(false);
  const [isDragging, setIsDragging] = useState(null);
  const [hoveredHex, setHoveredHex] = useState(null);
  const [speed, setSpeed] = useState('fast');
  const [stats, setStats] = useState({ visited: 0, pathLength: 0, time: 0 });
  const [unitSize, setUnitSize] = useState(1);
  const [canSnake, setCanSnake] = useState(false);
  const [snakePenalty, setSnakePenalty] = useState(1.5);
  const [showRibbon, setShowRibbon] = useState(false);
  const [heuristicWeight, setHeuristicWeight] = useState(1);
  const [showCellNumbers, setShowCellNumbers] = useState(false);
  const [showCostOverlay, setShowCostOverlay] = useState(false);
  const [costField, setCostField] = useState(new Map());
  const [flowVectors, setFlowVectors] = useState(new Map());
  const [visualPath, setVisualPath] = useState([]); // Full path for ribbon drawing
  const [reducedWaypoints, setReducedWaypoints] = useState([]); // LOS-reduced waypoints for smooth ribbon
  const [showFlowVectors, setShowFlowVectors] = useState(true);
  const [hasVisualized, setHasVisualized] = useState(false);
  const [wallEditMode, setWallEditMode] = useState(null);
  const [algorithmDropdownOpen, setAlgorithmDropdownOpen] = useState(false);
  const algorithmDropdownRef = useRef(null);
  
  const algorithmInfo = {
    dijkstra: { name: "Dijkstra's", optimal: true, complete: true, desc: "Explores uniformly by cost — guaranteed shortest path", icon: '🎯', supportsLineRotation: true },
    aStar: { name: 'A* Search', optimal: true, complete: true, desc: 'Cost + heuristic guided — the gold standard', icon: '⭐', supportsLineRotation: true },
    greedyBestFirst: { name: 'Greedy Best-First', optimal: false, complete: true, desc: 'Pure heuristic — very fast but often suboptimal', icon: '🏃', supportsLineRotation: false },
    swarm: { name: 'Swarm', optimal: false, complete: true, desc: 'Dynamic weight decreases over iterations', icon: '🐝', supportsLineRotation: false },
    convergentSwarm: { name: 'Convergent Swarm', optimal: false, complete: true, desc: 'Weight based on progress toward goal', icon: '🌀', supportsLineRotation: false },
    bidirectionalSwarm: { name: 'Bidirectional Swarm', optimal: false, complete: true, desc: 'Searches from both start and end simultaneously', icon: '↔️', supportsLineRotation: false },
    flowField: { name: 'Flow Field', optimal: true, complete: true, desc: 'Vector field pointing to goal — great for many units', icon: '🌊', supportsLineRotation: true },
    bfs: { name: 'Breadth-First (BFS)', optimal: 'unweighted', complete: true, desc: 'Level-by-level — optimal for uniform cost', icon: '📊', supportsLineRotation: false },
    dfs: { name: 'Depth-First (DFS)', optimal: false, complete: false, desc: 'Goes deep first — fast but unpredictable paths', icon: '🔍', supportsLineRotation: false },
  };

  useEffect(() => {
    const handleClickOutside = (e) => {
      if (algorithmDropdownRef.current && !algorithmDropdownRef.current.contains(e.target)) {
        setAlgorithmDropdownOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Compute LOS-reduced waypoints when path or ribbon state changes
  useEffect(() => {
    if (showRibbon && visualPath.length > 2) {
      const reduced = GridUtils.reducePathByLOS(visualPath, grid, gridType);
      setReducedWaypoints(reduced);
    } else {
      setReducedWaypoints([]);
    }
  }, [visualPath, showRibbon, grid, gridType]);

  const svgRef = useRef(null);
  const animationRef = useRef([]);
  const prevSettingsRef = useRef({ heuristicWeight, snakePenalty, canSnake, showRibbon, unitSize, selectedAlgorithm, gridType, heuristic, startOrientation, endOrientation });

  const CELL_SIZE = gridType === 'hex' ? 18 : 14;
  const SVG_WIDTH = 1200, SVG_HEIGHT = 800;
  const speedSettings = { fast: { visit: 5, path: 20 }, average: { visit: 20, path: 40 }, slow: { visit: 50, path: 80 } };
  const gridConfig = GridUtils.getConfig(gridType);

  const initializeGrid = useCallback(() => {
    const newGrid = new Map();
    if (gridType === 'hex') {
      const size = 18, sqrt3 = Math.sqrt(3), maxX = 580;
      for (let r = -14; r <= 14; r++) {
        const xOffsetFromR = size * (sqrt3 / 2) * r;
        const qSpacing = size * sqrt3;
        const minQ = Math.ceil((-maxX - xOffsetFromR) / qSpacing), maxQ = Math.floor((maxX - xOffsetFromR) / qSpacing);
        for (let q = minQ; q <= maxQ; q++) newGrid.set(GridUtils.cellKey(q, r), { q, r, isWall: false, isVisited: false, isPath: false, isStart: false, isEnd: false, animationState: 'none' });
      }
    } else {
      for (let q = -20; q <= 20; q++) for (let r = -13; r <= 13; r++) newGrid.set(GridUtils.cellKey(q, r), { q, r, isWall: false, isVisited: false, isPath: false, isStart: false, isEnd: false, animationState: 'none' });
    }
    const defaultStart = gridType === 'hex' ? { q: -14, r: 0 } : { q: -16, r: 0 };
    const defaultEnd = gridType === 'hex' ? { q: 14, r: 0 } : { q: 16, r: 0 };
    if (newGrid.has(GridUtils.cellKey(defaultStart.q, defaultStart.r))) newGrid.set(GridUtils.cellKey(defaultStart.q, defaultStart.r), { ...newGrid.get(GridUtils.cellKey(defaultStart.q, defaultStart.r)), isStart: true });
    if (newGrid.has(GridUtils.cellKey(defaultEnd.q, defaultEnd.r))) newGrid.set(GridUtils.cellKey(defaultEnd.q, defaultEnd.r), { ...newGrid.get(GridUtils.cellKey(defaultEnd.q, defaultEnd.r)), isEnd: true });
    return newGrid;
  }, [gridType]);

  useEffect(() => {
    const newGrid = initializeGrid();
    setGrid(newGrid);
    const defaultStart = gridType === 'hex' ? { q: -14, r: 0 } : { q: -16, r: 0 };
    const defaultEnd = gridType === 'hex' ? { q: 14, r: 0 } : { q: 16, r: 0 };
    setStartNode(defaultStart); setEndNode(defaultEnd);
    setHasVisualized(false); setFlowVectors(new Map()); setCostField(new Map()); setStats({ visited: 0, pathLength: 0, time: 0 });
    if (!gridConfig.unitSizes.includes(unitSize)) setUnitSize(gridConfig.unitSizes[0]);
    setStartOrientation(0); setEndOrientation(0); // Reset orientations
    setHeuristic(gridConfig.defaultHeuristic);
  }, [gridType, initializeGrid, gridConfig]);

  // Clamp orientations when unit size changes
  useEffect(() => {
    if (GridUtils.isOblongUnit(unitSize)) {
      const maxOrient = GridUtils.getNumOrientations(gridType, unitSize);
      if (startOrientation >= maxOrient) setStartOrientation(0);
      if (endOrientation >= maxOrient) setEndOrientation(0);
    }
  }, [unitSize, gridType, startOrientation, endOrientation]);

  const offsetX = SVG_WIDTH / 2, offsetY = SVG_HEIGHT / 2;
  const clearAnimations = useCallback(() => { animationRef.current.forEach(id => clearTimeout(id)); animationRef.current = []; }, []);
  const clearPath = useCallback(() => {
    clearAnimations();
    setGrid(prev => { const newGrid = new Map(prev); for (const [key, node] of newGrid) newGrid.set(key, { ...node, isVisited: false, isPath: false, animationState: 'none' }); return newGrid; });
    setStats({ visited: 0, pathLength: 0, time: 0 }); setFlowVectors(new Map()); setCostField(new Map()); setVisualPath([]); setReducedWaypoints([]);
  }, [clearAnimations]);
  const clearBoard = useCallback(() => {
    clearAnimations();
    setGrid(initializeGrid());
    const defaultStart = gridType === 'hex' ? { q: -14, r: 0 } : { q: -16, r: 0 };
    const defaultEnd = gridType === 'hex' ? { q: 14, r: 0 } : { q: 16, r: 0 };
    setStartNode(defaultStart); setEndNode(defaultEnd);
    setHasVisualized(false); setFlowVectors(new Map()); setCostField(new Map()); setStats({ visited: 0, pathLength: 0, time: 0 }); setVisualPath([]); setReducedWaypoints([]);
  }, [clearAnimations, initializeGrid, gridType]);

  const reconstructPath = (previous, endKey, startKey, formationState = null, orientationState = null) => {
    const path = [];
    let current = endKey;
    while (current && current !== startKey) { 
      path.unshift({ 
        key: current, 
        isCompact: formationState ? (formationState.get(current) ?? true) : true,
        orientation: orientationState ? (orientationState.get(current) ?? 0) : 0
      }); 
      current = previous.get(current); 
    }
    if (current === startKey) path.unshift({ 
      key: startKey, 
      isCompact: formationState ? (formationState.get(startKey) ?? true) : true,
      orientation: orientationState ? (orientationState.get(startKey) ?? 0) : 0
    });
    return path;
  };

  const animateAlgorithm = useCallback((visited, path, currentUnitSize = 1) => {
    const { visit: visitDelay, path: pathDelay } = speedSettings[speed];
    visited.forEach((key, index) => {
      const timeout = setTimeout(() => setGrid(prev => { const newGrid = new Map(prev); const node = newGrid.get(key); if (node && !node.isStart && !node.isEnd) newGrid.set(key, { ...node, animationState: 'visited' }); return newGrid; }), index * visitDelay);
      animationRef.current.push(timeout);
    });
    const pathStartTime = visited.length * visitDelay;
    const effectiveUnitSize = GridUtils.isOblongUnit(currentUnitSize) ? GridUtils.getOblongSize(currentUnitSize) : currentUnitSize;
    path.forEach((pathNode, index) => {
      const timeout = setTimeout(() => {
        setGrid(prev => {
          const newGrid = new Map(prev);
          const { key, isCompact, orientation = 0 } = pathNode;
          const { q, r } = GridUtils.parseKey(key);
          const formationCells = GridUtils.getFormationCells(gridType, q, r, currentUnitSize, orientation);
          const centerNode = newGrid.get(key);
          if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(key, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
          if (effectiveUnitSize > 1) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === key) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
          return newGrid;
        });
        if (index === path.length - 1) setIsRunning(false);
      }, pathStartTime + index * pathDelay);
      animationRef.current.push(timeout);
    });
    if (path.length === 0) { const timeout = setTimeout(() => setIsRunning(false), visited.length * visitDelay + 100); animationRef.current.push(timeout); }
  }, [speed, gridType]);

  const runAlgorithm = useCallback(() => {
    if (isRunning) return;
    clearPath(); setIsRunning(true);
    const startTime = performance.now();
    const algorithmGrid = new Map();
    for (const [key, node] of grid) algorithmGrid.set(key, { ...node, isVisited: false });
    const startKey = GridUtils.cellKey(startNode.q, startNode.r);
    let result;
    const runSelectedAlgorithm = (gridToUse, from, to, initOrient = null) => {
      switch (selectedAlgorithm) {
        case 'aStar': return Algorithms.aStar(gridToUse, from, to, heuristicWeight >= 10 ? 1000 : heuristicWeight, gridType, heuristic, unitSize, canSnake, snakePenalty, initOrient);
        case 'dijkstra': return Algorithms.dijkstra(gridToUse, from, to, gridType, unitSize, canSnake, snakePenalty, initOrient);
        case 'greedyBestFirst': return Algorithms.greedyBestFirst(gridToUse, from, to, gridType, heuristic, unitSize, canSnake, snakePenalty);
        case 'bfs': return Algorithms.bfs(gridToUse, from, to, gridType, unitSize, canSnake);
        case 'dfs': return Algorithms.dfs(gridToUse, from, to, gridType, unitSize, canSnake);
        case 'swarm': return Algorithms.swarm(gridToUse, from, to, gridType, heuristic, unitSize, canSnake, snakePenalty);
        case 'convergentSwarm': return Algorithms.convergentSwarm(gridToUse, from, to, gridType, heuristic, unitSize, canSnake, snakePenalty);
        case 'flowField': return Algorithms.flowField(gridToUse, from, to, gridType, unitSize, canSnake, snakePenalty);
        default: return Algorithms.aStar(gridToUse, from, to, 1, gridType, heuristic, unitSize, canSnake, snakePenalty, initOrient);
      }
    };
    if (selectedAlgorithm === 'bidirectionalSwarm') {
      const algoResult = Algorithms.bidirectionalSwarm(algorithmGrid, startNode, endNode, gridType, heuristic, unitSize, canSnake, snakePenalty);
      let path = [];
      if (algoResult.meetingPoint) {
        const pathFromStart = reconstructPath(algoResult.previousStart, algoResult.meetingPoint, startKey, algoResult.formationStateStart);
        const pathToEnd = [];
        let current = algoResult.meetingPoint;
        const endKey = GridUtils.cellKey(endNode.q, endNode.r);
        while (current && current !== endKey) { const next = algoResult.previousEnd.get(current); if (next) pathToEnd.push({ key: next, isCompact: algoResult.formationStateEnd?.get(next) ?? true }); current = next; }
        path = [...pathFromStart, ...pathToEnd];
      }
      result = { visited: algoResult.visited, path, gScore: algoResult.gScore };
    } else {
      const algoResult = runSelectedAlgorithm(algorithmGrid, startNode, endNode, startOrientation);
      let path;
      if (selectedAlgorithm === 'flowField' && algoResult.path) { path = algoResult.path; setFlowVectors(algoResult.flowVectors || new Map()); }
      else {
        path = reconstructPath(algoResult.previous, algoResult.endKey, startKey, algoResult.formationState, algoResult.orientationState);
      }
      result = { visited: algoResult.visited, path, gScore: selectedAlgorithm === 'flowField' ? (algoResult.costField || new Map()) : (algoResult.gScore || new Map()) };
    }
    // Store path data for ribbon visualization
    if (result.path.length > 0) {
      setVisualPath([...result.path]);
    } else {
      setVisualPath([]);
    }
    if (selectedAlgorithm !== 'flowField') setFlowVectors(new Map());
    setCostField(result.gScore || new Map());
    setStats({ visited: result.visited.length, pathLength: result.path.length, time: Math.round(performance.now() - startTime) });
    animateAlgorithm(result.visited, result.path, unitSize);
    setHasVisualized(true);
  }, [grid, startNode, endNode, selectedAlgorithm, heuristicWeight, unitSize, canSnake, snakePenalty, isRunning, clearPath, animateAlgorithm, gridType, heuristic, startOrientation]);

  const runInstantRecalc = useCallback((gridState, newStart, newEnd) => {
    const algorithmGrid = new Map();
    for (const [k, n] of gridState) algorithmGrid.set(k, { ...n, isVisited: false });
    const sKey = GridUtils.cellKey(newStart.q, newStart.r);
    let path = [], gScore = new Map();
    if (selectedAlgorithm === 'aStar') { const algoResult = Algorithms.aStar(algorithmGrid, newStart, newEnd, heuristicWeight >= 10 ? 1000 : heuristicWeight, gridType, heuristic, unitSize, canSnake, snakePenalty, startOrientation); path = reconstructPath(algoResult.previous, algoResult.endKey, sKey, algoResult.formationState, algoResult.orientationState); gScore = algoResult.gScore || new Map(); algoResult.visited.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); }); }
    else if (selectedAlgorithm === 'flowField') { const algoResult = Algorithms.flowField(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake, snakePenalty); path = algoResult.path || []; gScore = algoResult.costField || new Map(); setTimeout(() => setFlowVectors(algoResult.flowVectors || new Map()), 0); }
    else if (selectedAlgorithm === 'bidirectionalSwarm') {
      const algoResult = Algorithms.bidirectionalSwarm(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty);
      gScore = algoResult.gScore || new Map();
      if (algoResult.meetingPoint) { const pathFromStart = reconstructPath(algoResult.previousStart, algoResult.meetingPoint, sKey, algoResult.formationStateStart); const eKey = GridUtils.cellKey(newEnd.q, newEnd.r); const pathToEnd = []; let current = algoResult.meetingPoint; while (current && current !== eKey) { const next = algoResult.previousEnd.get(current); if (next) pathToEnd.push({ key: next, isCompact: algoResult.formationStateEnd?.get(next) ?? true }); current = next; } path = [...pathFromStart, ...pathToEnd]; }
      algoResult.visitedStart?.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); });
      algoResult.visitedEnd?.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); });
    }
    else if (selectedAlgorithm === 'dijkstra') { const algoResult = Algorithms.dijkstra(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake, snakePenalty, startOrientation); path = reconstructPath(algoResult.previous, algoResult.endKey, sKey, algoResult.formationState, algoResult.orientationState); gScore = algoResult.gScore || new Map(); algoResult.visited.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); }); }
    else {
      const algoResult = selectedAlgorithm === 'greedyBestFirst' ? Algorithms.greedyBestFirst(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty) : selectedAlgorithm === 'bfs' ? Algorithms.bfs(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake) : selectedAlgorithm === 'dfs' ? Algorithms.dfs(algorithmGrid, newStart, newEnd, gridType, unitSize, canSnake) : selectedAlgorithm === 'swarm' ? Algorithms.swarm(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty) : Algorithms.convergentSwarm(algorithmGrid, newStart, newEnd, gridType, heuristic, unitSize, canSnake, snakePenalty);
      path = reconstructPath(algoResult.previous, algoResult.endKey, sKey, algoResult.formationState); gScore = algoResult.gScore || new Map(); algoResult.visited.forEach(vKey => { const node = algorithmGrid.get(vKey); if (node) algorithmGrid.set(vKey, { ...node, isVisited: true }); });
    }
    return { path, gScore, algorithmGrid };
  }, [selectedAlgorithm, heuristicWeight, unitSize, canSnake, snakePenalty, gridType, heuristic, startOrientation]);

  const handleCellInteraction = useCallback((q, r, isClick = false) => {
    if (isRunning) return;
    const key = GridUtils.cellKey(q, r);
    const node = grid.get(key);
    if (!node) return;
    if (isClick) {
      if (node.isStart) { setIsDragging('start'); return; }
      if (node.isEnd) { setIsDragging('end'); return; }
      const shouldBeWall = !node.isWall;
      setIsDragging('wall'); setWallEditMode(shouldBeWall ? 'add' : 'remove');
      
      // Update wall and recalculate path if visualized
      const newGrid = new Map(grid);
      newGrid.set(key, { ...node, isWall: shouldBeWall });
      
      if (hasVisualized) {
        for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
        const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, startNode, endNode);
        setVisualPath([...path]);
        for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const pathNode of path) {
          const { key: pKey, isCompact, orientation = 0 } = pathNode;
          const { q: pq, r: pr } = GridUtils.parseKey(pKey);
          const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize, orientation);
          const centerNode = newGrid.get(pKey);
          if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
          if (GridUtils.isMultiUnit(unitSize)) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
        }
        setCostField(gScore);
        setStats(s => ({ ...s, pathLength: path.length }));
      }
      setGrid(newGrid);
      return;
    }
    if (isDragging === 'start' && !node.isEnd && !node.isWall) {
      const newStart = { q, r };
      setStartNode(newStart);
      const newGrid = new Map(grid);
      for (const [k, n] of newGrid) if (n.isStart && k !== key) newGrid.set(k, { ...n, isStart: false });
      newGrid.set(key, { ...node, isStart: true });
      let newGScore = new Map();
      if (hasVisualized) {
        for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
        const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, newStart, endNode);
        newGScore = gScore;
        setVisualPath([...path]);
        for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const pathNode of path) {
          const { key: pKey, isCompact, orientation = 0 } = pathNode;
          const { q: pq, r: pr } = GridUtils.parseKey(pKey);
          const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize, orientation);
          const centerNode = newGrid.get(pKey);
          if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
          if (GridUtils.isMultiUnit(unitSize)) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
        }
        setStats(s => ({ ...s, pathLength: path.length }));
      }
      setGrid(newGrid);
      if (hasVisualized) setCostField(newGScore);
      return;
    }
    if (isDragging === 'end' && !node.isStart && !node.isWall) {
      const newEnd = { q, r };
      setEndNode(newEnd);
      const newGrid = new Map(grid);
      for (const [k, n] of newGrid) if (n.isEnd && k !== key) newGrid.set(k, { ...n, isEnd: false });
      newGrid.set(key, { ...node, isEnd: true });
      let newGScore = new Map();
      if (hasVisualized) {
        for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
        const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, startNode, newEnd);
        newGScore = gScore;
        setVisualPath([...path]);
        for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
        for (const pathNode of path) {
          const { key: pKey, isCompact, orientation = 0 } = pathNode;
          const { q: pq, r: pr } = GridUtils.parseKey(pKey);
          const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize, orientation);
          const centerNode = newGrid.get(pKey);
          if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
          if (GridUtils.isMultiUnit(unitSize)) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
        }
        setStats(s => ({ ...s, pathLength: path.length }));
      }
      setGrid(newGrid);
      if (hasVisualized) setCostField(newGScore);
      return;
    }
    if (!node.isStart && !node.isEnd && isDragging === 'wall') {
      const shouldBeWall = wallEditMode === 'add';
      if (node.isWall !== shouldBeWall) {
        // Update the wall
        const newGrid = new Map(grid);
        newGrid.set(key, { ...node, isWall: shouldBeWall });
        
        // Recalculate path if we have a visualization
        if (hasVisualized) {
          for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
          const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, startNode, endNode);
          setVisualPath([...path]);
          for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
          for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
          for (const pathNode of path) {
            const { key: pKey, isCompact, orientation = 0 } = pathNode;
            const { q: pq, r: pr } = GridUtils.parseKey(pKey);
            const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize, orientation);
            const centerNode = newGrid.get(pKey);
            if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
            if (GridUtils.isMultiUnit(unitSize)) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
          }
          setCostField(gScore);
          setStats(s => ({ ...s, pathLength: path.length }));
        }
        setGrid(newGrid);
      }
    }
  }, [grid, isRunning, isDragging, startNode, endNode, hasVisualized, unitSize, runInstantRecalc, wallEditMode, gridType]);

  useEffect(() => {
    const prev = prevSettingsRef.current;
    // Note: showRibbon is not included here - it's purely visual and doesn't affect path calculation
    const settingsChanged = prev.heuristicWeight !== heuristicWeight || prev.snakePenalty !== snakePenalty || prev.canSnake !== canSnake || prev.unitSize !== unitSize || prev.selectedAlgorithm !== selectedAlgorithm || prev.gridType !== gridType || prev.heuristic !== heuristic || prev.startOrientation !== startOrientation || prev.endOrientation !== endOrientation;
    prevSettingsRef.current = { heuristicWeight, snakePenalty, canSnake, showRibbon, unitSize, selectedAlgorithm, gridType, heuristic, startOrientation, endOrientation };
    if (!settingsChanged || !hasVisualized || isRunning) return;
    let computedGScore = new Map(), computedPathLength = 0, computedPath = [];
    setGrid(currentGrid => {
      const newGrid = new Map(currentGrid);
      for (const [k, n] of newGrid) if (n.animationState !== 'none' || n.isVisited) newGrid.set(k, { ...n, isVisited: false, isPath: false, animationState: 'none' });
      const { path, gScore, algorithmGrid } = runInstantRecalc(newGrid, startNode, endNode);
      computedGScore = gScore; computedPathLength = path.length; computedPath = [...path];
      for (const [k, n] of algorithmGrid) if (n.isVisited && newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd) newGrid.set(k, { ...existing, animationState: 'visited' }); }
      for (const [k] of gScore) if (newGrid.has(k)) { const existing = newGrid.get(k); if (!existing.isStart && !existing.isEnd && !existing.isWall && existing.animationState === 'none') newGrid.set(k, { ...existing, animationState: 'visited' }); }
      for (const pathNode of path) {
        const { key: pKey, isCompact, orientation = 0 } = pathNode;
        const { q: pq, r: pr } = GridUtils.parseKey(pKey);
        const formationCells = GridUtils.getFormationCells(gridType, pq, pr, unitSize, orientation);
        const centerNode = newGrid.get(pKey);
        if (centerNode && !centerNode.isStart && !centerNode.isEnd) newGrid.set(pKey, { ...centerNode, animationState: isCompact ? 'path' : 'pathSnaking', isPath: true });
        if (GridUtils.isMultiUnit(unitSize)) formationCells.forEach(cell => { const cellKey = GridUtils.cellKey(cell.q, cell.r); if (cellKey === pKey) return; const cellNode = newGrid.get(cellKey); if (cellNode && !cellNode.isStart && !cellNode.isEnd && !cellNode.isWall) newGrid.set(cellKey, { ...cellNode, animationState: isCompact ? 'pathFormation' : 'pathSnakingFormation', isPath: true }); });
      }
      return newGrid;
    });
    setCostField(computedGScore); setStats(s => ({ ...s, pathLength: computedPathLength })); setVisualPath(computedPath);
  }, [heuristicWeight, snakePenalty, canSnake, unitSize, selectedAlgorithm, hasVisualized, isRunning, startNode, endNode, runInstantRecalc, gridType, heuristic, startOrientation, endOrientation]);

  const handleMouseDown = (q, r) => handleCellInteraction(q, r, true);
  const handleMouseEnter = (q, r) => { setHoveredHex({ q, r }); if (isDragging) handleCellInteraction(q, r, false); };
  const handleMouseUp = () => { setIsDragging(null); setWallEditMode(null); };
  
  const handleTouchStart = useCallback((e) => {
    if (isRunning) return;
    const touch = e.touches[0];
    const svg = svgRef.current;
    if (!svg) return;
    const rect = svg.getBoundingClientRect();
    const scaleX = SVG_WIDTH / rect.width;
    const scaleY = SVG_HEIGHT / rect.height;
    const x = (touch.clientX - rect.left) * scaleX - offsetX;
    const y = (touch.clientY - rect.top) * scaleY - offsetY;
    const cell = gridType === 'hex' ? GridUtils.axialRound((Math.sqrt(3)/3 * x - 1/3 * y) / CELL_SIZE, (2/3 * y) / CELL_SIZE) : { q: Math.round(x / (CELL_SIZE * 2)), r: Math.round(y / (CELL_SIZE * 2)) };
    const key = GridUtils.cellKey(cell.q, cell.r);
    const node = grid.get(key);
    if (!node) return;
    if (node.isStart) { setIsDragging('start'); e.preventDefault(); }
    else if (node.isEnd) { setIsDragging('end'); e.preventDefault(); }
    else { setIsDragging('wall'); setWallEditMode(!node.isWall ? 'add' : 'remove'); setGrid(prev => { const newGrid = new Map(prev); newGrid.set(key, { ...node, isWall: !node.isWall }); return newGrid; }); e.preventDefault(); }
  }, [grid, isRunning, gridType, CELL_SIZE, offsetX, offsetY]);

  const handleTouchMove = useCallback((e) => {
    if (!isDragging || isRunning) return;
    const touch = e.touches[0];
    const svg = svgRef.current;
    if (!svg) return;
    const rect = svg.getBoundingClientRect();
    const scaleX = SVG_WIDTH / rect.width;
    const scaleY = SVG_HEIGHT / rect.height;
    const x = (touch.clientX - rect.left) * scaleX - offsetX;
    const y = (touch.clientY - rect.top) * scaleY - offsetY;
    const cell = gridType === 'hex' ? GridUtils.axialRound((Math.sqrt(3)/3 * x - 1/3 * y) / CELL_SIZE, (2/3 * y) / CELL_SIZE) : { q: Math.round(x / (CELL_SIZE * 2)), r: Math.round(y / (CELL_SIZE * 2)) };
    handleCellInteraction(cell.q, cell.r, false);
    e.preventDefault();
  }, [isDragging, isRunning, gridType, CELL_SIZE, offsetX, offsetY, handleCellInteraction]);

  const handleTouchEnd = useCallback(() => { setIsDragging(null); setWallEditMode(null); }, []);
  const generateMaze = useCallback(() => { clearPath(); setHasVisualized(false); setGrid(prev => { const newGrid = new Map(prev); for (const [key, node] of newGrid) if (!node.isStart && !node.isEnd) newGrid.set(key, { ...node, isWall: Math.random() < 0.3 }); return newGrid; }); }, [clearPath]);
  const isInStartFormation = useCallback((q, r) => { 
    const effectiveSize = GridUtils.isOblongUnit(unitSize) ? GridUtils.getOblongSize(unitSize) : unitSize;
    if (effectiveSize === 1) return q === startNode.q && r === startNode.r;
    if (GridUtils.isOblongUnit(unitSize)) {
      return GridUtils.getOblongCells(gridType, startNode.q, startNode.r, unitSize, startOrientation).some(c => c.q === q && c.r === r);
    }
    return GridUtils.getFormationCells(gridType, startNode.q, startNode.r, unitSize, 0).some(c => c.q === q && c.r === r); 
  }, [startNode, unitSize, gridType, startOrientation]);
  const isInEndFormation = useCallback((q, r) => { 
    const effectiveSize = GridUtils.isOblongUnit(unitSize) ? GridUtils.getOblongSize(unitSize) : unitSize;
    if (effectiveSize === 1) return q === endNode.q && r === endNode.r;
    if (GridUtils.isOblongUnit(unitSize)) {
      return GridUtils.getOblongCells(gridType, endNode.q, endNode.r, unitSize, endOrientation).some(c => c.q === q && c.r === r);
    }
    return GridUtils.getFormationCells(gridType, endNode.q, endNode.r, unitSize, 0).some(c => c.q === q && c.r === r); 
  }, [endNode, unitSize, gridType, endOrientation]);
  const getCellFill = (node) => { const inStart = isInStartFormation(node.q, node.r), inEnd = isInEndFormation(node.q, node.r); if (inStart) return '#0077BB'; if (inEnd) return '#EE7733'; if (node.isWall) return '#0d0d1a'; switch (node.animationState) { case 'visited': return '#88CCEE'; case 'path': case 'pathFormation': return '#FFDD44'; case 'pathSnaking': case 'pathSnakingFormation': return '#FFFFFF'; default: break; } return '#1a1a2e'; };
  const getCellStroke = (node, isHovered) => { if (isHovered) return '#fff'; const inStart = isInStartFormation(node.q, node.r), inEnd = isInEndFormation(node.q, node.r); if (inStart) return '#0077BB'; if (inEnd) return '#EE7733'; if (node.isWall) return '#333'; return '#0f3460'; };
  const getFlowArrow = (q, r, direction) => { const { x, y } = GridUtils.cellToPixel(gridType, q, r, CELL_SIZE); const cx = x + offsetX, cy = y + offsetY; const targetPixel = GridUtils.cellToPixel(gridType, q + direction.q, r + direction.r, CELL_SIZE); const angle = Math.atan2(targetPixel.y - y, targetPixel.x - x); const arrowLength = CELL_SIZE * 0.5, arrowHeadSize = CELL_SIZE * 0.2; const startX = cx - Math.cos(angle) * (arrowLength * 0.3), startY = cy - Math.sin(angle) * (arrowLength * 0.3); const tipX = cx + Math.cos(angle) * arrowLength * 0.7, tipY = cy + Math.sin(angle) * arrowLength * 0.7; const headAngle1 = angle + Math.PI * 0.75, headAngle2 = angle - Math.PI * 0.75; return { line: { x1: startX, y1: startY, x2: tipX, y2: tipY }, head: `${tipX},${tipY} ${tipX + Math.cos(headAngle1) * arrowHeadSize},${tipY + Math.sin(headAngle1) * arrowHeadSize} ${tipX + Math.cos(headAngle2) * arrowHeadSize},${tipY + Math.sin(headAngle2) * arrowHeadSize}` }; };

  const renderCell = (node) => {
    const { x, y } = GridUtils.cellToPixel(gridType, node.q, node.r, CELL_SIZE);
    const cx = x + offsetX, cy = y + offsetY;
    const isHovered = hoveredHex && hoveredHex.q === node.q && hoveredHex.r === node.r;
    const inStart = isInStartFormation(node.q, node.r), inEnd = isInEndFormation(node.q, node.r);
    const isPrimaryStart = node.q === startNode.q && node.r === startNode.r, isPrimaryEnd = node.q === endNode.q && node.r === endNode.r;
    const cellKey = GridUtils.cellKey(node.q, node.r);
    const flowVector = flowVectors.get(cellKey);
    const arrow = showFlowVectors && flowVector ? getFlowArrow(node.q, node.r, flowVector.direction) : null;
    const cellCost = costField.get(cellKey);
    const isPathCell = ['path', 'pathFormation', 'pathSnaking', 'pathSnakingFormation'].includes(node.animationState);
    const showCost = showCostOverlay && cellCost !== undefined && (node.animationState === 'visited' || isPathCell);
    const costTextColor = isPathCell ? '#000' : '#fff';
    const isOnPath = node.animationState === 'path' || node.animationState === 'pathFormation';
    const arrowColor = isOnPath ? '#000' : '#1a237e', arrowStroke = isOnPath ? '#FFDD44' : '#fff';

    if (gridType === 'hex') {
      const corners = GridUtils.hexCorners(cx, cy, CELL_SIZE - 1);
      return (
        <g key={cellKey}>
          <polygon points={corners.map(c => `${c.x},${c.y}`).join(' ')} fill={getCellFill(node)} stroke={getCellStroke(node, isHovered)} strokeWidth={isHovered ? 2 : (inStart || inEnd) && GridUtils.isMultiUnit(unitSize) ? 2 : 1} onMouseDown={() => handleMouseDown(node.q, node.r)} onMouseEnter={() => handleMouseEnter(node.q, node.r)} style={{ cursor: 'pointer' }} />
          {isPrimaryStart && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="14" fontWeight="bold" pointerEvents="none">▶</text>}
          {isPrimaryEnd && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="14" fontWeight="bold" pointerEvents="none">◎</text>}
          {showCellNumbers && <text x={cx} y={cy + (isPrimaryStart || isPrimaryEnd ? 8 : 0)} textAnchor="middle" dominantBaseline="central" fill="#666" fontSize="7" pointerEvents="none">{node.q},{node.r}</text>}
          {showCost && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill={costTextColor} fontSize="8" fontWeight="bold" pointerEvents="none" style={{ textShadow: isPathCell ? '0 0 2px #fff' : '0 0 3px #000' }}>{cellCost.toFixed(1)}</text>}
          {arrow && <><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowStroke} strokeWidth="2" pointerEvents="none" /><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowColor} strokeWidth="1" pointerEvents="none" /><polygon points={arrow.head} fill={arrowColor} stroke={arrowStroke} strokeWidth="0.5" pointerEvents="none" /></>}
        </g>
      );
    } else {
      const halfSize = CELL_SIZE - 1;
      return (
        <g key={cellKey}>
          <rect x={cx - halfSize} y={cy - halfSize} width={halfSize * 2} height={halfSize * 2} fill={getCellFill(node)} stroke={getCellStroke(node, isHovered)} strokeWidth={isHovered ? 2 : (inStart || inEnd) && GridUtils.isMultiUnit(unitSize) ? 2 : 1} onMouseDown={() => handleMouseDown(node.q, node.r)} onMouseEnter={() => handleMouseEnter(node.q, node.r)} style={{ cursor: 'pointer' }} />
          {isPrimaryStart && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="12" fontWeight="bold" pointerEvents="none">▶</text>}
          {isPrimaryEnd && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill="#fff" fontSize="12" fontWeight="bold" pointerEvents="none">◎</text>}
          {showCellNumbers && <text x={cx} y={cy + (isPrimaryStart || isPrimaryEnd ? 6 : 0)} textAnchor="middle" dominantBaseline="central" fill="#666" fontSize="6" pointerEvents="none">{node.q},{node.r}</text>}
          {showCost && <text x={cx} y={cy} textAnchor="middle" dominantBaseline="central" fill={costTextColor} fontSize="7" fontWeight="bold" pointerEvents="none" style={{ textShadow: isPathCell ? '0 0 2px #fff' : '0 0 3px #000' }}>{cellCost.toFixed(1)}</text>}
          {arrow && <><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowStroke} strokeWidth="2" pointerEvents="none" /><line x1={arrow.line.x1} y1={arrow.line.y1} x2={arrow.line.x2} y2={arrow.line.y2} stroke={arrowColor} strokeWidth="1" pointerEvents="none" /><polygon points={arrow.head} fill={arrowColor} stroke={arrowStroke} strokeWidth="0.5" pointerEvents="none" /></>}
        </g>
      );
    }
  };

  const getHeuristicLabel = (h) => { switch (h) { case 'hex': return 'Hex Distance'; case 'manhattan': return 'Manhattan'; case 'chebyshev': return 'Chebyshev'; case 'euclidean': return 'Euclidean'; default: return h; } };

  return (
    <div style={{ fontFamily: 'system-ui, -apple-system, sans-serif', background: '#0a0a1a', minHeight: '100vh', color: '#e8e8e8' }}>
      <nav style={{ background: 'linear-gradient(90deg, #1a1a2e, #16213e)', padding: '12px 16px', display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', borderBottom: '1px solid #0f3460', WebkitOverflowScrolling: 'touch', position: 'relative', zIndex: 100, overflow: 'visible' }}>
        <h1 style={{ margin: 0, fontSize: '18px', fontWeight: 700, background: 'linear-gradient(90deg, #64b5f6, #ffc107)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', marginRight: '16px' }}>⬡ Pathfinding Visualizer</h1>
        <select value={gridType} onChange={(e) => setGridType(e.target.value)} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}><option value="hex">Hex Grid (6-dir)</option><option value="square4">Square (4-dir)</option><option value="square8">Square (8-dir)</option></select>
        <div ref={algorithmDropdownRef} style={{ position: 'relative', zIndex: 1000 }}>
          <button onClick={() => !isRunning && setAlgorithmDropdownOpen(!algorithmDropdownOpen)} disabled={isRunning}
            style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '8px', minWidth: '220px', justifyContent: 'space-between' }}>
            <span style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
              <span>{algorithmInfo[selectedAlgorithm].icon}</span>
              <span>{algorithmInfo[selectedAlgorithm].name}</span>
              <span style={{ fontSize: '9px', padding: '2px 5px', borderRadius: '3px', background: algorithmInfo[selectedAlgorithm].optimal === true ? 'rgba(76, 175, 80, 0.3)' : algorithmInfo[selectedAlgorithm].optimal ? 'rgba(255, 193, 7, 0.3)' : 'rgba(238, 119, 51, 0.3)', color: algorithmInfo[selectedAlgorithm].optimal === true ? '#4caf50' : algorithmInfo[selectedAlgorithm].optimal ? '#ffc107' : '#EE7733' }}>
                {algorithmInfo[selectedAlgorithm].optimal === true ? '✓ Optimal' : algorithmInfo[selectedAlgorithm].optimal ? `✓ ${algorithmInfo[selectedAlgorithm].optimal}` : '✗ Suboptimal'}
              </span>
            </span>
            <span style={{ fontSize: '10px', marginLeft: '4px' }}>▼</span>
          </button>
          {algorithmDropdownOpen && (
            <div style={{ position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: '#1a1a2e', border: '1px solid #0f3460', borderRadius: '8px', boxShadow: '0 8px 32px rgba(0,0,0,0.8)', zIndex: 9999, minWidth: '340px', overflow: 'hidden' }}>
              {Object.entries(algorithmInfo).map(([key, info]) => (
                <div key={key} onClick={() => { setSelectedAlgorithm(key); setAlgorithmDropdownOpen(false); }}
                  style={{ padding: '10px 14px', cursor: 'pointer', background: selectedAlgorithm === key ? 'rgba(100, 181, 246, 0.2)' : 'transparent', borderLeft: selectedAlgorithm === key ? '3px solid #64b5f6' : '3px solid transparent' }}
                  onMouseEnter={(e) => { if (selectedAlgorithm !== key) e.currentTarget.style.background = 'rgba(100, 181, 246, 0.1)'; }}
                  onMouseLeave={(e) => { e.currentTarget.style.background = selectedAlgorithm === key ? 'rgba(100, 181, 246, 0.2)' : 'transparent'; }}>
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '3px' }}>
                    <span style={{ display: 'flex', alignItems: 'center', gap: '8px', fontWeight: 500, color: '#e8e8e8' }}>
                      <span>{info.icon}</span><span>{info.name}</span>
                    </span>
                    <div style={{ display: 'flex', gap: '6px' }}>
                      <span style={{ fontSize: '10px', padding: '2px 6px', borderRadius: '3px', background: info.optimal === true ? 'rgba(76, 175, 80, 0.3)' : info.optimal ? 'rgba(255, 193, 7, 0.3)' : 'rgba(238, 119, 51, 0.3)', color: info.optimal === true ? '#4caf50' : info.optimal ? '#ffc107' : '#EE7733' }}>
                        {info.optimal === true ? '✓ Optimal' : info.optimal ? `✓ ${info.optimal}` : '✗ Suboptimal'}
                      </span>
                      {!info.complete && <span style={{ fontSize: '10px', padding: '2px 6px', borderRadius: '3px', background: 'rgba(238, 119, 51, 0.3)', color: '#EE7733' }}>Incomplete</span>}
                    </div>
                  </div>
                  <div style={{ fontSize: '11px', color: '#90a4ae', paddingLeft: '26px' }}>{info.desc}</div>
                </div>
              ))}
            </div>
          )}
        </div>
        {['aStar', 'greedyBestFirst', 'swarm', 'convergentSwarm', 'bidirectionalSwarm'].includes(selectedAlgorithm) && <select value={heuristic} onChange={(e) => setHeuristic(e.target.value)} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{gridConfig.heuristics.map(h => <option key={h} value={h}>{getHeuristicLabel(h)}</option>)}</select>}
        {['aStar'].includes(selectedAlgorithm) && <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(100, 181, 246, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #1e88e5' }}><span style={{ fontSize: '10px', color: '#90a4ae' }}>w:</span><input type="range" min="0" max="10" step="0.1" value={heuristicWeight} onChange={(e) => setHeuristicWeight(parseFloat(e.target.value))} disabled={isRunning} style={{ width: '80px', cursor: isRunning ? 'not-allowed' : 'pointer', accentColor: '#88CCEE' }} /><span style={{ fontSize: '11px', fontWeight: 'bold', color: heuristicWeight <= 1 ? '#88CCEE' : heuristicWeight < 3 ? '#DDAA00' : '#EE7733', minWidth: '30px' }}>{heuristicWeight >= 10 ? '∞' : heuristicWeight.toFixed(1)}</span></div>}
        <button onClick={runAlgorithm} disabled={isRunning} style={{ background: 'linear-gradient(90deg, #0077BB, #88CCEE)', color: '#fff', border: 'none', borderRadius: '4px', padding: '8px 20px', cursor: isRunning ? 'not-allowed' : 'pointer', fontWeight: 600, fontSize: '14px', boxShadow: '0 2px 8px rgba(0, 119, 187, 0.4)' }}>{isRunning ? 'Running...' : 'Visualize!'}</button>
        <button onClick={clearPath} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px' }}>Clear Path</button>
        <button onClick={clearBoard} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px' }}>Clear Board</button>
        <select value={speed} onChange={(e) => setSpeed(e.target.value)} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}><option value="fast">Fast</option><option value="average">Medium</option><option value="slow">Slow</option></select>
      </nav>
      <nav style={{ background: 'rgba(15, 52, 96, 0.8)', padding: '8px 16px', display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap', borderBottom: '1px solid #0f3460', overflowX: 'auto', WebkitOverflowScrolling: 'touch', position: 'relative', zIndex: 50 }}>
        <button onClick={generateMaze} disabled={isRunning} style={{ background: '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px' }}>Random Walls</button>
        <div style={{ width: '1px', height: '24px', background: '#0f3460' }} />
        <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(170, 68, 153, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #AA4499' }}><span style={{ fontSize: '12px', color: '#AA4499' }}>Unit:</span>{gridConfig.unitSizes.map(size => <button key={size} onClick={() => setUnitSize(size)} disabled={isRunning} style={{ background: unitSize === size ? '#AA4499' : '#16213e', color: '#e8e8e8', border: `1px solid ${unitSize === size ? '#AA4499' : '#0f3460'}`, borderRadius: '4px', padding: '4px 8px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '11px', fontWeight: unitSize === size ? 'bold' : 'normal' }}>{gridConfig.unitLabels[size]}</button>)}</div>
        {GridUtils.isOblongUnit(unitSize) && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(0, 119, 187, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #0077BB' }}>
            <span style={{ fontSize: '11px', color: '#0077BB' }}>Start:</span>
            <button onClick={() => setStartOrientation((startOrientation + GridUtils.getNumOrientations(gridType, unitSize) - 1) % GridUtils.getNumOrientations(gridType, unitSize))} disabled={isRunning} style={{ background: '#16213e', color: '#0077BB', border: '1px solid #0077BB', borderRadius: '4px', padding: '2px 6px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '11px' }}>↺</button>
            <span style={{ fontSize: '10px', color: '#0077BB', minWidth: '20px', textAlign: 'center' }}>{startOrientation + 1}/{GridUtils.getNumOrientations(gridType, unitSize)}</span>
            <button onClick={() => setStartOrientation((startOrientation + 1) % GridUtils.getNumOrientations(gridType, unitSize))} disabled={isRunning} style={{ background: '#16213e', color: '#0077BB', border: '1px solid #0077BB', borderRadius: '4px', padding: '2px 6px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '11px' }}>↻</button>
          </div>
        )}
        {GridUtils.isOblongUnit(unitSize) && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(238, 119, 51, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #EE7733' }}>
            <span style={{ fontSize: '11px', color: '#EE7733' }}>End:</span>
            <button onClick={() => setEndOrientation((endOrientation + GridUtils.getNumOrientations(gridType, unitSize) - 1) % GridUtils.getNumOrientations(gridType, unitSize))} disabled={isRunning} style={{ background: '#16213e', color: '#EE7733', border: '1px solid #EE7733', borderRadius: '4px', padding: '2px 6px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '11px' }}>↺</button>
            <span style={{ fontSize: '10px', color: '#EE7733', minWidth: '20px', textAlign: 'center' }}>{endOrientation + 1}/{GridUtils.getNumOrientations(gridType, unitSize)}</span>
            <button onClick={() => setEndOrientation((endOrientation + 1) % GridUtils.getNumOrientations(gridType, unitSize))} disabled={isRunning} style={{ background: '#16213e', color: '#EE7733', border: '1px solid #EE7733', borderRadius: '4px', padding: '2px 6px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '11px' }}>↻</button>
          </div>
        )}
        {GridUtils.isOblongUnit(unitSize) && !['aStar', 'dijkstra', 'flowField'].includes(selectedAlgorithm) && (
          <div style={{ display: 'flex', alignItems: 'center', gap: '4px', background: 'rgba(255, 152, 0, 0.2)', padding: '4px 8px', borderRadius: '4px', border: '1px solid #ff9800' }}>
            <span style={{ fontSize: '10px', color: '#ff9800' }}>⚠ {selectedAlgorithm === 'greedyBestFirst' ? 'Greedy' : selectedAlgorithm === 'bfs' ? 'BFS' : selectedAlgorithm === 'dfs' ? 'DFS' : selectedAlgorithm.replace('Swarm', '')} ignores rotation</span>
          </div>
        )}
        <div style={{ width: '100px', display: 'flex', justifyContent: 'center' }}>{GridUtils.isMultiUnit(unitSize) ? <button onClick={() => setCanSnake(!canSnake)} disabled={isRunning} style={{ background: canSnake ? '#DDAA00' : '#16213e', color: canSnake ? '#000' : '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px', fontWeight: canSnake ? 'bold' : 'normal', width: '100%' }}>{canSnake ? '🐍 Snake ✓' : '🐍 Snake'}</button> : <span style={{ color: '#455a64', fontSize: '11px' }}>(1-unit)</span>}</div>
        {GridUtils.isMultiUnit(unitSize) && canSnake && <div style={{ display: 'flex', alignItems: 'center', gap: '6px', background: 'rgba(221, 170, 0, 0.15)', padding: '4px 10px', borderRadius: '4px', border: '1px solid #DDAA00' }}><span style={{ fontSize: '11px', color: '#DDAA00' }}>Cost:</span><input type="range" min="0" max="10" step="0.5" value={snakePenalty} onChange={(e) => setSnakePenalty(parseFloat(e.target.value))} disabled={isRunning} style={{ width: '60px', cursor: isRunning ? 'not-allowed' : 'pointer', accentColor: '#DDAA00' }} /><span style={{ fontSize: '11px', fontWeight: 'bold', color: '#DDAA00' }}>{snakePenalty.toFixed(1)}</span></div>}
        <button onClick={() => setShowRibbon(!showRibbon)} disabled={isRunning} style={{ background: showRibbon ? '#9c27b0' : '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: isRunning ? 'not-allowed' : 'pointer', fontSize: '13px', fontWeight: showRibbon ? 'bold' : 'normal' }}>{showRibbon ? '🎀 Ribbon ✓' : '🎀 Ribbon'}</button>
        <div style={{ width: '1px', height: '24px', background: '#0f3460' }} />
        <button onClick={() => setShowCellNumbers(!showCellNumbers)} style={{ background: showCellNumbers ? '#2196f3' : '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{showCellNumbers ? '🔢 Coords ✓' : '🔢 Coords'}</button>
        <button onClick={() => { setShowCostOverlay(!showCostOverlay); if (!showCostOverlay && selectedAlgorithm === 'flowField') setShowFlowVectors(false); }} style={{ background: showCostOverlay ? '#e91e63' : '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{showCostOverlay ? '💰 Costs ✓' : '💰 Costs'}</button>
        {selectedAlgorithm === 'flowField' && <button onClick={() => { setShowFlowVectors(!showFlowVectors); if (!showFlowVectors) setShowCostOverlay(false); }} style={{ background: showFlowVectors ? '#00bcd4' : '#16213e', color: '#e8e8e8', border: '1px solid #0f3460', borderRadius: '4px', padding: '6px 12px', cursor: 'pointer', fontSize: '13px' }}>{showFlowVectors ? '→ Arrows ✓' : '→ Arrows'}</button>}
      </nav>
      <div style={{ background: 'rgba(22, 33, 62, 0.9)', padding: '8px 16px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '12px', borderBottom: '1px solid #0f3460', fontSize: '12px', position: 'relative', zIndex: 10 }}>
        <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#0077BB', borderRadius: 2 }}></span> Start</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#EE7733', borderRadius: 2 }}></span> Target</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#0d0d1a', borderRadius: 2, border: '1px solid #333' }}></span> Wall</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#88CCEE', borderRadius: 2 }}></span> Visited</span><span style={{ display: 'flex', alignItems: 'center', gap: '4px' }}><span style={{ width: 14, height: 14, background: '#FFDD44', borderRadius: 2 }}></span> Path</span></div>
        <div style={{ display: 'flex', gap: '16px' }}><span>Visited: <strong style={{ color: '#88CCEE' }}>{stats.visited}</strong></span><span>Path: <strong style={{ color: '#FFDD44' }}>{stats.pathLength}</strong></span><span>Time: <strong style={{ color: '#ffc107' }}>{stats.time}ms</strong></span></div>
      </div>
      <div className="grid-container" style={{ display: 'flex', justifyContent: 'center', padding: '10px', background: '#0a0a1a', userSelect: 'none', overflow: 'auto', WebkitOverflowScrolling: 'touch', position: 'relative', zIndex: 1 }}><svg ref={svgRef} width={SVG_WIDTH} height={SVG_HEIGHT} viewBox={`0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`} style={{ background: '#0d0d1a', borderRadius: '8px', userSelect: 'none', flexShrink: 0, touchAction: isDragging ? 'none' : 'pan-x pan-y' }} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd} onDragStart={(e) => e.preventDefault()}>
        {Array.from(grid.values()).map(node => renderCell(node))}
        {/* Smooth path ribbon overlay */}
        {showRibbon && visualPath.length > 1 && (() => {
          // Use LOS-reduced waypoints for ribbon drawing (smoother, fewer segments)
          const pathSource = reducedWaypoints.length > 1 ? reducedWaypoints : visualPath;
          
          // Convert path to pixel coordinates
          const pathPoints = pathSource.map(node => {
            const pos = GridUtils.parseKey(node.key);
            const pixel = GridUtils.cellToPixel(gridType, pos.q, pos.r, CELL_SIZE);
            return { 
              x: pixel.x + offsetX, 
              y: pixel.y + offsetY,
              orientation: node.orientation || 0,
              isCompact: node.isCompact !== false
            };
          });
          
          if (pathPoints.length < 2) return null;
          
          // Calculate ribbon width from formation size
          const compactWidth = GridUtils.getFormationWidthForDirection(gridType, unitSize, 0, 0, CELL_SIZE);
          
          // Helper to check if a pixel position is inside a wall or off-grid
          const isPixelBlocked = (px, py) => {
            const localX = px - offsetX;
            const localY = py - offsetY;
            let cell;
            if (gridType === 'hex') {
              cell = GridUtils.axialRound(
                (Math.sqrt(3)/3 * localX - 1/3 * localY) / CELL_SIZE,
                (2/3 * localY) / CELL_SIZE
              );
            } else {
              cell = { q: Math.round(localX / (CELL_SIZE * 2)), r: Math.round(localY / (CELL_SIZE * 2)) };
            }
            const key = GridUtils.cellKey(cell.q, cell.r);
            const node = grid.get(key);
            // Blocked if wall OR missing (off grid)
            return !node || node.isWall;
          };
          
          // Find max safe distance by checking multiple points along the ray
          const findSafeDistance = (cx, cy, nx, ny, maxDist) => {
            if (maxDist <= 0) return 0;
            const stepSize = CELL_SIZE * 0.25; // Check every ~25% of a cell
            let safeDist = 0;
            
            for (let d = stepSize; d <= maxDist; d += stepSize) {
              if (isPixelBlocked(cx + nx * d, cy + ny * d)) {
                // Found a wall - return distance minus margin
                return Math.max(0, safeDist);
              }
              safeDist = d;
            }
            
            // Check final point
            if (!isPixelBlocked(cx + nx * maxDist, cy + ny * maxDist)) {
              return maxDist;
            }
            return Math.max(0, safeDist);
          };
          
          // Generate dense samples along the path with curved corners
          const generateSamples = () => {
            const samples = [];
            const sampleDist = 8; // Sample every 8 pixels
            const cornerRadius = CELL_SIZE * 1.2; // How much to round corners
            
            if (pathPoints.length < 2) return pathPoints;
            
            if (pathPoints.length === 2) {
              // Just two points - straight line
              const p1 = pathPoints[0], p2 = pathPoints[1];
              const dx = p2.x - p1.x, dy = p2.y - p1.y;
              const segLen = Math.sqrt(dx * dx + dy * dy);
              const numSamples = Math.max(2, Math.ceil(segLen / sampleDist));
              for (let j = 0; j <= numSamples; j++) {
                const t = j / numSamples;
                samples.push({ x: p1.x + dx * t, y: p1.y + dy * t, isCompact: p1.isCompact && p2.isCompact });
              }
              return samples;
            }
            
            // Multiple waypoints - add curves at corners
            for (let i = 0; i < pathPoints.length; i++) {
              const prev = i > 0 ? pathPoints[i - 1] : null;
              const curr = pathPoints[i];
              const next = i < pathPoints.length - 1 ? pathPoints[i + 1] : null;
              
              if (!prev) {
                // Start point - just add it
                samples.push({ ...curr });
                continue;
              }
              
              if (!next) {
                // End point - line from last sample to here
                const lastSample = samples[samples.length - 1];
                const dx = curr.x - lastSample.x, dy = curr.y - lastSample.y;
                const segLen = Math.sqrt(dx * dx + dy * dy);
                const numSamples = Math.max(1, Math.ceil(segLen / sampleDist));
                for (let j = 1; j <= numSamples; j++) {
                  const t = j / numSamples;
                  samples.push({ x: lastSample.x + dx * t, y: lastSample.y + dy * t, isCompact: curr.isCompact });
                }
                continue;
              }
              
              // Middle waypoint - calculate corner curve
              const toPrevX = prev.x - curr.x, toPrevY = prev.y - curr.y;
              const toNextX = next.x - curr.x, toNextY = next.y - curr.y;
              const prevDist = Math.sqrt(toPrevX * toPrevX + toPrevY * toPrevY) || 1;
              const nextDist = Math.sqrt(toNextX * toNextX + toNextY * toNextY) || 1;
              
              // Calculate corner rounding distance
              const roundDist = Math.min(cornerRadius, prevDist * 0.4, nextDist * 0.4);
              
              // Point where curve starts (coming from prev)
              const curveStartX = curr.x + (toPrevX / prevDist) * roundDist;
              const curveStartY = curr.y + (toPrevY / prevDist) * roundDist;
              
              // Point where curve ends (going to next)
              const curveEndX = curr.x + (toNextX / nextDist) * roundDist;
              const curveEndY = curr.y + (toNextY / nextDist) * roundDist;
              
              // Line from last sample to curve start
              const lastSample = samples[samples.length - 1];
              const dx1 = curveStartX - lastSample.x, dy1 = curveStartY - lastSample.y;
              const seg1Len = Math.sqrt(dx1 * dx1 + dy1 * dy1);
              const numSamples1 = Math.max(1, Math.ceil(seg1Len / sampleDist));
              for (let j = 1; j <= numSamples1; j++) {
                const t = j / numSamples1;
                samples.push({ 
                  x: lastSample.x + dx1 * t, 
                  y: lastSample.y + dy1 * t, 
                  isCompact: prev.isCompact && curr.isCompact 
                });
              }
              
              // Quadratic bezier curve through the corner
              const numCurveSamples = Math.max(4, Math.ceil(roundDist / sampleDist) * 2);
              for (let j = 1; j <= numCurveSamples; j++) {
                const t = j / numCurveSamples;
                const mt = 1 - t;
                // Quadratic bezier: (1-t)²·P0 + 2(1-t)t·P1 + t²·P2
                const x = mt * mt * curveStartX + 2 * mt * t * curr.x + t * t * curveEndX;
                const y = mt * mt * curveStartY + 2 * mt * t * curr.y + t * t * curveEndY;
                samples.push({ x, y, isCompact: curr.isCompact });
              }
            }
            
            return samples;
          };
          
          const samples = generateSamples();
          
          // Generate ribbon edges with smart wall avoidance
          const leftEdge = [];
          const rightEdge = [];
          
          for (let i = 0; i < samples.length; i++) {
            const pt = samples[i];
            
            // Calculate tangent direction from neighbors
            let dx, dy;
            if (i === 0) {
              dx = samples[Math.min(1, samples.length - 1)].x - samples[0].x;
              dy = samples[Math.min(1, samples.length - 1)].y - samples[0].y;
            } else if (i === samples.length - 1) {
              dx = samples[i].x - samples[Math.max(0, i - 1)].x;
              dy = samples[i].y - samples[Math.max(0, i - 1)].y;
            } else {
              dx = samples[i + 1].x - samples[i - 1].x;
              dy = samples[i + 1].y - samples[i - 1].y;
            }
            
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            const nx = -dy / len; // Perpendicular (left)
            const ny = dx / len;
            
            // Find available space on each side (always search full formation width)
            const halfWidth = compactWidth / 2;
            const leftSpace = findSafeDistance(pt.x, pt.y, nx, ny, compactWidth);
            const rightSpace = findSafeDistance(pt.x, pt.y, -nx, -ny, compactWidth);
            
            let leftOffset, rightOffset;
            
            // Calculate how much width we want (compact = full, snaking = fill corridor)
            const targetWidth = pt.isCompact ? compactWidth : Math.min(leftSpace + rightSpace, compactWidth);
            const targetHalf = targetWidth / 2;
            
            // Distribute width, shifting away from walls
            if (leftSpace >= targetHalf && rightSpace >= targetHalf) {
              // Both sides have room - center it
              leftOffset = targetHalf;
              rightOffset = targetHalf;
            } else if (leftSpace < targetHalf) {
              // Wall on left - use what's available, extend right
              leftOffset = leftSpace;
              rightOffset = Math.min(rightSpace, targetWidth - leftOffset);
            } else {
              // Wall on right - use what's available, extend left  
              rightOffset = rightSpace;
              leftOffset = Math.min(leftSpace, targetWidth - rightOffset);
            }
            
            leftEdge.push({ x: pt.x + nx * leftOffset, y: pt.y + ny * leftOffset });
            rightEdge.push({ x: pt.x - nx * rightOffset, y: pt.y - ny * rightOffset });
          }
          
          // Smooth the edges to reduce jaggedness
          const smoothEdge = (edge, iterations = 2) => {
            if (edge.length < 3) return edge;
            let result = [...edge];
            for (let iter = 0; iter < iterations; iter++) {
              const smoothed = [result[0]]; // Keep first point
              for (let i = 1; i < result.length - 1; i++) {
                // Simple moving average with neighbors
                smoothed.push({
                  x: (result[i - 1].x + result[i].x * 2 + result[i + 1].x) / 4,
                  y: (result[i - 1].y + result[i].y * 2 + result[i + 1].y) / 4
                });
              }
              smoothed.push(result[result.length - 1]); // Keep last point
              result = smoothed;
            }
            return result;
          };
          
          const smoothLeftEdge = smoothEdge(leftEdge);
          const smoothRightEdge = smoothEdge(rightEdge);
          
          // Build ribbon polygon path
          const ribbonPath = `M ${smoothLeftEdge[0].x},${smoothLeftEdge[0].y} ` +
            smoothLeftEdge.slice(1).map(p => `L ${p.x},${p.y}`).join(' ') +
            ` L ${smoothRightEdge[smoothRightEdge.length - 1].x},${smoothRightEdge[smoothRightEdge.length - 1].y} ` +
            smoothRightEdge.slice(0, -1).reverse().map(p => `L ${p.x},${p.y}`).join(' ') +
            ' Z';
          
          // Build center line path
          const centerPath = `M ${samples[0].x},${samples[0].y} ` +
            samples.slice(1).map(p => `L ${p.x},${p.y}`).join(' ');
          
          // Build edge paths for outline (use smoothed edges)
          const leftPath = `M ${smoothLeftEdge[0].x},${smoothLeftEdge[0].y} ` +
            smoothLeftEdge.slice(1).map(p => `L ${p.x},${p.y}`).join(' ');
          const rightPath = `M ${smoothRightEdge[0].x},${smoothRightEdge[0].y} ` +
            smoothRightEdge.slice(1).map(p => `L ${p.x},${p.y}`).join(' ');
          
          return (
            <g style={{ pointerEvents: 'none' }}>
              {/* Ribbon fill */}
              <path d={ribbonPath} fill="rgba(255, 235, 150, 0.6)" stroke="none" />
              {/* Ribbon edges */}
              <path d={leftPath} fill="none" stroke="rgba(0, 0, 0, 0.7)" strokeWidth={2} strokeLinecap="round" />
              <path d={rightPath} fill="none" stroke="rgba(0, 0, 0, 0.7)" strokeWidth={2} strokeLinecap="round" />
              {/* Center line */}
              <path d={centerPath} fill="none" stroke="rgba(180, 150, 50, 0.9)" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
              {/* Waypoint markers */}
              {pathPoints.map((wp, i) => (
                <g key={`wp-${i}`}>
                  <circle cx={wp.x} cy={wp.y} r={7} fill="#000" opacity="0.7" />
                  <circle
                    cx={wp.x}
                    cy={wp.y}
                    r={5}
                    fill={i === 0 ? '#0077BB' : i === pathPoints.length - 1 ? '#EE7733' : (wp.isCompact ? '#FFDD44' : '#CC66FF')}
                    stroke="#fff"
                    strokeWidth={2}
                  />
                </g>
              ))}
            </g>
          );
        })()}
      </svg></div>
      
      {/* Formula Display */}
      <div style={{ background: 'linear-gradient(180deg, #0d1520, #0a0a1a)', padding: '20px', borderTop: '1px solid #0f3460' }}>
        <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
          <h3 style={{ color: '#64b5f6', marginBottom: '16px', fontSize: '16px', display: 'flex', alignItems: 'center', gap: '8px' }}>
            📐 Algorithm: <span style={{ color: '#FFDD44' }}>{
              selectedAlgorithm === 'aStar' ? 'A* Search' :
              selectedAlgorithm === 'dijkstra' ? "Dijkstra's Algorithm" :
              selectedAlgorithm === 'greedyBestFirst' ? 'Greedy Best-First Search' :
              selectedAlgorithm === 'bfs' ? 'Breadth-First Search (BFS)' :
              selectedAlgorithm === 'dfs' ? 'Depth-First Search (DFS)' :
              selectedAlgorithm === 'swarm' ? 'Swarm Algorithm' :
              selectedAlgorithm === 'convergentSwarm' ? 'Convergent Swarm' :
              selectedAlgorithm === 'bidirectionalSwarm' ? 'Bidirectional Swarm' :
              selectedAlgorithm === 'flowField' ? 'Flow Field' : selectedAlgorithm
            }</span>
          </h3>
          
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '20px' }}>
            {/* Core Formula */}
            <div style={{ background: 'rgba(100, 181, 246, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #1e88e5' }}>
              <h4 style={{ color: '#90caf9', marginBottom: '12px', fontSize: '14px' }}>Core Formula</h4>
              <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                {selectedAlgorithm === 'aStar' && <>f(n) = g(n) + w × h(n)</>}
                {selectedAlgorithm === 'dijkstra' && <>f(n) = g(n)</>}
                {selectedAlgorithm === 'greedyBestFirst' && <>f(n) = h(n)</>}
                {selectedAlgorithm === 'bfs' && <>Queue: FIFO order</>}
                {selectedAlgorithm === 'dfs' && <>Stack: LIFO order</>}
                {selectedAlgorithm === 'swarm' && <>f(n) = g(n) + w(i) × h(n)<br/>w(i) = 1 + (h/i) × 2</>}
                {selectedAlgorithm === 'convergentSwarm' && <>f(n) = g(n) + w(p) × h(n)<br/>w(p) = 1 + (1 - p) × 3</>}
                {selectedAlgorithm === 'bidirectionalSwarm' && <>Forward: f(n) = g(n) + h(n→end)<br/>Backward: f(n) = g(n) + h(n→start)</>}
                {selectedAlgorithm === 'flowField' && <>cost(n) = min(cost(neighbors)) + move_cost</>}
              </div>
              <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                {selectedAlgorithm === 'aStar' && <>
                  <div><strong style={{ color: '#88CCEE' }}>f(n)</strong> = total estimated cost through node n</div>
                  <div><strong style={{ color: '#88CCEE' }}>g(n)</strong> = actual cost from start to n</div>
                  <div><strong style={{ color: '#88CCEE' }}>h(n)</strong> = heuristic estimate from n to goal</div>
                  <div><strong style={{ color: '#88CCEE' }}>w</strong> = heuristic weight ({heuristicWeight >= 10 ? '∞' : heuristicWeight.toFixed(1)}) — higher values favor speed over optimality</div>
                </>}
                {selectedAlgorithm === 'dijkstra' && <>
                  <div><strong style={{ color: '#88CCEE' }}>f(n)</strong> = priority for expansion</div>
                  <div><strong style={{ color: '#88CCEE' }}>g(n)</strong> = actual cost from start to n</div>
                  <div>No heuristic — explores uniformly in all directions</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>✓ Guarantees optimal path</div>
                </>}
                {selectedAlgorithm === 'greedyBestFirst' && <>
                  <div><strong style={{ color: '#88CCEE' }}>f(n)</strong> = priority based purely on heuristic</div>
                  <div><strong style={{ color: '#88CCEE' }}>h(n)</strong> = estimated distance to goal</div>
                  <div>Ignores path cost — very fast but may find suboptimal paths</div>
                  <div style={{ color: '#EE7733', marginTop: '4px' }}>⚠ Does not guarantee optimal path</div>
                </>}
                {selectedAlgorithm === 'bfs' && <>
                  <div>Explores nodes level-by-level using a <strong style={{ color: '#88CCEE' }}>queue</strong></div>
                  <div>First-In-First-Out: oldest discovered nodes explored first</div>
                  <div>Treats all edges as equal cost</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>✓ Guarantees shortest path (by hop count)</div>
                </>}
                {selectedAlgorithm === 'dfs' && <>
                  <div>Explores as deep as possible using a <strong style={{ color: '#88CCEE' }}>stack</strong></div>
                  <div>Last-In-First-Out: most recent nodes explored first</div>
                  <div>Memory efficient but unpredictable path quality</div>
                  <div style={{ color: '#EE7733', marginTop: '4px' }}>⚠ Usually finds suboptimal paths</div>
                </>}
                {selectedAlgorithm === 'swarm' && <>
                  <div><strong style={{ color: '#88CCEE' }}>w(i)</strong> = dynamic weight based on iteration count</div>
                  <div><strong style={{ color: '#88CCEE' }}>i</strong> = current iteration number</div>
                  <div>Early: high heuristic weight (greedy) → Late: balanced</div>
                  <div style={{ color: '#AA4499', marginTop: '4px' }}>Mimics swarm behavior converging on target</div>
                </>}
                {selectedAlgorithm === 'convergentSwarm' && <>
                  <div><strong style={{ color: '#88CCEE' }}>w(p)</strong> = weight based on progress toward goal</div>
                  <div><strong style={{ color: '#88CCEE' }}>p</strong> = progress ratio (0 = at start, 1 = at goal)</div>
                  <div>Far from goal: greedy → Near goal: careful</div>
                  <div style={{ color: '#AA4499', marginTop: '4px' }}>Accelerates then refines approach</div>
                </>}
                {selectedAlgorithm === 'bidirectionalSwarm' && <>
                  <div>Two simultaneous searches from start and end</div>
                  <div>Searches meet in the middle and merge paths</div>
                  <div>Can dramatically reduce search space</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>✓ Often faster than unidirectional search</div>
                </>}
                {selectedAlgorithm === 'flowField' && <>
                  <div>Computes <strong style={{ color: '#88CCEE' }}>cost field</strong> from goal outward</div>
                  <div>Each cell stores direction to lowest-cost neighbor</div>
                  <div>Any unit can follow arrows to reach goal</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>✓ Efficient for many units with same destination</div>
                </>}
              </div>
            </div>

            {/* Heuristic Function */}
            <div style={{ background: 'rgba(170, 68, 153, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #AA4499' }}>
              <h4 style={{ color: '#ce93d8', marginBottom: '12px', fontSize: '14px' }}>Heuristic: {getHeuristicLabel(heuristic)}</h4>
              <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                {heuristic === 'hex' && <>h = max(|Δx|, |Δy|, |Δz|)<br/><span style={{ fontSize: '12px', color: '#b0bec5' }}>where x+y+z=0 (cube coords)</span></>}
                {heuristic === 'manhattan' && <>h = |x₁ - x₂| + |y₁ - y₂|</>}
                {heuristic === 'chebyshev' && <>h = max(|x₁ - x₂|, |y₁ - y₂|)</>}
                {heuristic === 'euclidean' && <>h = √((x₁-x₂)² + (y₁-y₂)²)</>}
              </div>
              <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                {heuristic === 'hex' && <>
                  <div>Converts axial (q,r) to cube coordinates (x,y,z)</div>
                  <div>Cube constraint: x + y + z = 0</div>
                  <div>Distance = maximum absolute difference</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>✓ Exact distance for hex grids</div>
                </>}
                {heuristic === 'manhattan' && <>
                  <div>Sum of horizontal and vertical distances</div>
                  <div>Also called "taxicab" or "L1" distance</div>
                  <div>Assumes only cardinal (4-directional) movement</div>
                  <div style={{ color: gridType === 'square4' ? '#FFDD44' : '#EE7733', marginTop: '4px' }}>
                    {gridType === 'square4' ? '✓ Optimal for 4-directional grids' : '⚠ Overestimates for diagonal movement'}
                  </div>
                </>}
                {heuristic === 'chebyshev' && <>
                  <div>Maximum of horizontal or vertical distance</div>
                  <div>Also called "chessboard" distance</div>
                  <div>Assumes diagonal moves cost same as cardinal</div>
                  <div style={{ color: gridType === 'square8' ? '#FFDD44' : '#EE7733', marginTop: '4px' }}>
                    {gridType === 'square8' ? '✓ Good for 8-directional grids' : '⚠ May underestimate without diagonals'}
                  </div>
                </>}
                {heuristic === 'euclidean' && <>
                  <div>Straight-line distance (Pythagorean theorem)</div>
                  <div>Most accurate real-world distance</div>
                  <div>Never overestimates (admissible)</div>
                  <div style={{ color: '#FFDD44', marginTop: '4px' }}>✓ Admissible for any grid type</div>
                </>}
              </div>
            </div>

            {/* Movement Cost */}
            <div style={{ background: 'rgba(238, 119, 51, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #EE7733' }}>
              <h4 style={{ color: '#ffab91', marginBottom: '12px', fontSize: '14px' }}>Movement Cost</h4>
              <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                {gridType === 'hex' && <>cost = 1.0 per hex</>}
                {gridType === 'square4' && <>cost = 1.0 per cell</>}
                {gridType === 'square8' && <>cardinal = 1.0<br/>diagonal = √2 ≈ 1.414</>}
              </div>
              <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                {gridType === 'hex' && <>
                  <div>All 6 hex directions have equal cost</div>
                  <div>Hex grids have uniform distance in all directions</div>
                  <div>No diagonal penalty needed</div>
                </>}
                {gridType === 'square4' && <>
                  <div>4 cardinal directions: ↑ ↓ ← →</div>
                  <div>Each step costs 1.0 unit</div>
                  <div>No diagonal movement allowed</div>
                </>}
                {gridType === 'square8' && <>
                  <div>8 directions: cardinals + diagonals</div>
                  <div>Diagonal = √(1² + 1²) = √2 ≈ 1.414</div>
                  <div>Accurate Euclidean movement costs</div>
                </>}
              </div>
            </div>

            {/* Formation/Snake Info - only show if unit size > 1 */}
            {GridUtils.isMultiUnit(unitSize) && (
              <div style={{ background: 'rgba(221, 170, 0, 0.1)', borderRadius: '8px', padding: '16px', border: '1px solid #DDAA00' }}>
                <h4 style={{ color: '#ffeb3b', marginBottom: '12px', fontSize: '14px' }}>Formation: {gridConfig.unitLabels[unitSize]}</h4>
                <div style={{ fontFamily: 'monospace', fontSize: '15px', color: '#fff', marginBottom: '12px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '4px' }}>
                  clearance_cost = blocked_neighbors × 0.1
                  {canSnake && <><br/>snake_cost = {(snakePenalty * Math.sqrt(unitSize)).toFixed(2)} × (first:1 | cont:0.15)</>}
                </div>
                <div style={{ fontSize: '12px', color: '#b0bec5', lineHeight: '1.6' }}>
                  <div><strong style={{ color: '#DDAA00' }}>Formation cells:</strong> {unitSize} cells move together</div>
                  <div><strong style={{ color: '#DDAA00' }}>Clearance penalty:</strong> prefers open spaces</div>
                  {canSnake ? <>
                    <div><strong style={{ color: '#DDAA00' }}>Snake mode:</strong> enabled</div>
                    <div>• First snake move: +{(snakePenalty * Math.sqrt(unitSize)).toFixed(2)} cost</div>
                    <div>• Continued snaking: +{(snakePenalty * Math.sqrt(unitSize) * 0.15).toFixed(2)} cost</div>
                    <div>• Scale factor: √{unitSize} = {Math.sqrt(unitSize).toFixed(2)}×</div>
                    <div>• Reforming: uses clearance cost (no snake penalty)</div>
                    <div style={{ color: '#fff', marginTop: '4px' }}>White path = snaking through tight spaces</div>
                  </> : <>
                    <div><strong style={{ color: '#DDAA00' }}>Snake mode:</strong> disabled</div>
                    <div>Formation must fit completely in all spaces</div>
                  </>}
                </div>
              </div>
            )}
          </div>

          {/* Algorithm Characteristics */}
          <div style={{ marginTop: '20px', padding: '16px', background: 'rgba(136, 204, 238, 0.1)', borderRadius: '8px', border: '1px solid #0f3460' }}>
            <h4 style={{ color: '#88CCEE', marginBottom: '12px', fontSize: '14px' }}>Algorithm Characteristics</h4>
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '16px', fontSize: '12px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Optimal:</span>
                <span style={{ color: ['dijkstra', 'aStar', 'flowField'].includes(selectedAlgorithm) ? '#4caf50' : selectedAlgorithm === 'bfs' ? '#ffc107' : '#EE7733', fontWeight: 'bold' }}>
                  {['dijkstra', 'aStar', 'flowField'].includes(selectedAlgorithm) ? 'Yes' : selectedAlgorithm === 'bfs' ? 'Yes (unweighted)' : 'No'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Complete:</span>
                <span style={{ color: selectedAlgorithm === 'dfs' ? '#EE7733' : '#4caf50', fontWeight: 'bold' }}>
                  {selectedAlgorithm === 'dfs' ? 'No (may loop)' : 'Yes'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Time Complexity:</span>
                <span style={{ color: '#88CCEE', fontFamily: 'monospace' }}>
                  {selectedAlgorithm === 'dijkstra' ? 'O((V+E) log V)' :
                   selectedAlgorithm === 'aStar' ? 'O(b^d) worst' :
                   selectedAlgorithm === 'bfs' ? 'O(V + E)' :
                   selectedAlgorithm === 'dfs' ? 'O(V + E)' :
                   selectedAlgorithm === 'flowField' ? 'O(V log V)' :
                   'O(b^d)'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Space:</span>
                <span style={{ color: '#88CCEE', fontFamily: 'monospace' }}>
                  {selectedAlgorithm === 'dfs' ? 'O(d)' :
                   selectedAlgorithm === 'flowField' ? 'O(V)' :
                   'O(V)'}
                </span>
              </div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                <span style={{ color: '#b0bec5' }}>Data Structure:</span>
                <span style={{ color: '#ce93d8' }}>
                  {selectedAlgorithm === 'bfs' ? 'Queue (FIFO)' :
                   selectedAlgorithm === 'dfs' ? 'Stack (LIFO)' :
                   'Priority Queue (Min-Heap)'}
                </span>
              </div>
              {showRibbon && (
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                  <span style={{ color: '#b0bec5' }}>Path Ribbon:</span>
                  <span style={{ color: '#9c27b0', fontWeight: 'bold' }}>Active</span>
                  <span style={{ color: '#78909c', fontSize: '10px' }}>(LOS-reduced: {reducedWaypoints.length} waypoints)</span>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<PathfindingVisualizer />);
  </script>
</body>
</html>
